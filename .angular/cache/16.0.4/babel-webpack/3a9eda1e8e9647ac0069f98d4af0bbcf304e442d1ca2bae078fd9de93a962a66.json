{"ast":null,"code":"\"use strict\";\n\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar _asyncToGenerator = require(\"D:/graduation project/Graduation_Project-Dubbizel--main/Graduation_Project-Dubbizel--main/Dubbizel_Angular/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseExternalAccountClient = exports.CLOUD_RESOURCE_MANAGER = exports.EXTERNAL_ACCOUNT_TYPE = exports.EXPIRATION_TIME_OFFSET = void 0;\nconst stream = require(\"stream\");\nconst authclient_1 = require(\"./authclient\");\nconst sts = require(\"./stscredentials\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */\nconst STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */\nconst STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/** The default OAuth scope to request when none is provided. */\nconst DEFAULT_OAUTH_SCOPE = 'https://www.googleapis.com/auth/cloud-platform';\n/** Default impersonated token lifespan in seconds.*/\nconst DEFAULT_TOKEN_LIFESPAN = 3600;\n/**\n * Offset to take into account network delays and server clock skews.\n */\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * The credentials JSON file type for external account clients.\n * There are 3 types of JSON configs:\n * 1. authorized_user => Google end user credential\n * 2. service_account => Google service account credential\n * 3. external_Account => non-GCP service (eg. AWS, Azure, K8s)\n */\nexports.EXTERNAL_ACCOUNT_TYPE = 'external_account';\n/** Cloud resource manager URL used to retrieve project information. */\nexports.CLOUD_RESOURCE_MANAGER = 'https://cloudresourcemanager.googleapis.com/v1/projects/';\n/** The workforce audience pattern. */\nconst WORKFORCE_AUDIENCE_PATTERN = '//iam.googleapis.com/locations/[^/]+/workforcePools/[^/]+/providers/.+';\n/**\n * Base external account client. This is used to instantiate AuthClients for\n * exchanging external account credentials for GCP access token and authorizing\n * requests to GCP APIs.\n * The base class implements common logic for exchanging various type of\n * external credentials for GCP access token. The logic of determining and\n * retrieving the external credential based on the environment and\n * credential_source will be left for the subclasses.\n */\nclass BaseExternalAccountClient extends authclient_1.AuthClient {\n  /**\n   * Instantiate a BaseExternalAccountClient instance using the provided JSON\n   * object loaded from an external account credentials file.\n   * @param options The external account options object typically loaded\n   *   from the external account JSON credential file.\n   * @param additionalOptions Optional additional behavior customization\n   *   options. These currently customize expiration threshold time and\n   *   whether to retry on 401/403 API request errors.\n   */\n  constructor(options, additionalOptions) {\n    var _a, _b;\n    super();\n    if (options.type !== exports.EXTERNAL_ACCOUNT_TYPE) {\n      throw new Error(`Expected \"${exports.EXTERNAL_ACCOUNT_TYPE}\" type but ` + `received \"${options.type}\"`);\n    }\n    this.clientAuth = options.client_id ? {\n      confidentialClientType: 'basic',\n      clientId: options.client_id,\n      clientSecret: options.client_secret\n    } : undefined;\n    this.stsCredential = new sts.StsCredentials(options.token_url, this.clientAuth);\n    // Default OAuth scope. This could be overridden via public property.\n    this.scopes = [DEFAULT_OAUTH_SCOPE];\n    this.cachedAccessToken = null;\n    this.audience = options.audience;\n    this.subjectTokenType = options.subject_token_type;\n    this.quotaProjectId = options.quota_project_id;\n    this.workforcePoolUserProject = options.workforce_pool_user_project;\n    const workforceAudiencePattern = new RegExp(WORKFORCE_AUDIENCE_PATTERN);\n    if (this.workforcePoolUserProject && !this.audience.match(workforceAudiencePattern)) {\n      throw new Error('workforcePoolUserProject should not be set for non-workforce pool ' + 'credentials.');\n    }\n    this.serviceAccountImpersonationUrl = options.service_account_impersonation_url;\n    this.serviceAccountImpersonationLifetime = (_b = (_a = options.service_account_impersonation) === null || _a === void 0 ? void 0 : _a.token_lifetime_seconds) !== null && _b !== void 0 ? _b : DEFAULT_TOKEN_LIFESPAN;\n    // As threshold could be zero,\n    // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n    // zero value.\n    if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {\n      this.eagerRefreshThresholdMillis = exports.EXPIRATION_TIME_OFFSET;\n    } else {\n      this.eagerRefreshThresholdMillis = additionalOptions.eagerRefreshThresholdMillis;\n    }\n    this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n    this.projectId = null;\n    this.projectNumber = this.getProjectNumber(this.audience);\n  }\n  /** The service account email to be impersonated, if available. */\n  getServiceAccountEmail() {\n    var _a;\n    if (this.serviceAccountImpersonationUrl) {\n      // Parse email from URL. The formal looks as follows:\n      // https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/name@project-id.iam.gserviceaccount.com:generateAccessToken\n      const re = /serviceAccounts\\/(?<email>[^:]+):generateAccessToken$/;\n      const result = re.exec(this.serviceAccountImpersonationUrl);\n      return ((_a = result === null || result === void 0 ? void 0 : result.groups) === null || _a === void 0 ? void 0 : _a.email) || null;\n    }\n    return null;\n  }\n  /**\n   * Provides a mechanism to inject GCP access tokens directly.\n   * When the provided credential expires, a new credential, using the\n   * external account options, is retrieved.\n   * @param credentials The Credentials object to set on the current client.\n   */\n  setCredentials(credentials) {\n    super.setCredentials(credentials);\n    this.cachedAccessToken = credentials;\n  }\n  /**\n   * @return A promise that resolves with the current GCP access token\n   *   response. If the current credential is expired, a new one is retrieved.\n   */\n  getAccessToken() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // If cached access token is unavailable or expired, force refresh.\n      if (!_this.cachedAccessToken || _this.isExpired(_this.cachedAccessToken)) {\n        yield _this.refreshAccessTokenAsync();\n      }\n      // Return GCP access token in GetAccessTokenResponse format.\n      return {\n        token: _this.cachedAccessToken.access_token,\n        res: _this.cachedAccessToken.res\n      };\n    })();\n  }\n  /**\n   * The main authentication interface. It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * The result has the form:\n   * { Authorization: 'Bearer <access_token_value>' }\n   */\n  getRequestHeaders() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const accessTokenResponse = yield _this2.getAccessToken();\n      const headers = {\n        Authorization: `Bearer ${accessTokenResponse.token}`\n      };\n      return _this2.addSharedMetadataHeaders(headers);\n    })();\n  }\n  request(opts, callback) {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n  /**\n   * @return A promise that resolves with the project ID corresponding to the\n   *   current workload identity pool or current workforce pool if\n   *   determinable. For workforce pool credential, it returns the project ID\n   *   corresponding to the workforcePoolUserProject.\n   *   This is introduced to match the current pattern of using the Auth\n   *   library:\n   *   const projectId = await auth.getProjectId();\n   *   const url = `https://dns.googleapis.com/dns/v1/projects/${projectId}`;\n   *   const res = await client.request({ url });\n   *   The resource may not have permission\n   *   (resourcemanager.projects.get) to call this API or the required\n   *   scopes may not be selected:\n   *   https://cloud.google.com/resource-manager/reference/rest/v1/projects/get#authorization-scopes\n   */\n  getProjectId() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const projectNumber = _this3.projectNumber || _this3.workforcePoolUserProject;\n      if (_this3.projectId) {\n        // Return previously determined project ID.\n        return _this3.projectId;\n      } else if (projectNumber) {\n        // Preferable not to use request() to avoid retrial policies.\n        const headers = yield _this3.getRequestHeaders();\n        const response = yield _this3.transporter.request({\n          headers,\n          url: `${exports.CLOUD_RESOURCE_MANAGER}${projectNumber}`,\n          responseType: 'json'\n        });\n        _this3.projectId = response.data.projectId;\n        return _this3.projectId;\n      }\n      return null;\n    })();\n  }\n  /**\n   * Authenticates the provided HTTP request, processes it and resolves with the\n   * returned response.\n   * @param opts The HTTP request options.\n   * @param retry Whether the current attempt is a retry after a failed attempt.\n   * @return A promise that resolves with the successful response.\n   */\n  requestAsync(opts, retry = false) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      let response;\n      try {\n        const requestHeaders = yield _this4.getRequestHeaders();\n        opts.headers = opts.headers || {};\n        if (requestHeaders && requestHeaders['x-goog-user-project']) {\n          opts.headers['x-goog-user-project'] = requestHeaders['x-goog-user-project'];\n        }\n        if (requestHeaders && requestHeaders.Authorization) {\n          opts.headers.Authorization = requestHeaders.Authorization;\n        }\n        response = yield _this4.transporter.request(opts);\n      } catch (e) {\n        const res = e.response;\n        if (res) {\n          const statusCode = res.status;\n          // Retry the request for metadata if the following criteria are true:\n          // - We haven't already retried.  It only makes sense to retry once.\n          // - The response was a 401 or a 403\n          // - The request didn't send a readableStream\n          // - forceRefreshOnFailure is true\n          const isReadableStream = res.config.data instanceof stream.Readable;\n          const isAuthErr = statusCode === 401 || statusCode === 403;\n          if (!retry && isAuthErr && !isReadableStream && _this4.forceRefreshOnFailure) {\n            yield _this4.refreshAccessTokenAsync();\n            return yield _this4.requestAsync(opts, true);\n          }\n        }\n        throw e;\n      }\n      return response;\n    })();\n  }\n  /**\n   * Forces token refresh, even if unexpired tokens are currently cached.\n   * External credentials are exchanged for GCP access tokens via the token\n   * exchange endpoint and other settings provided in the client options\n   * object.\n   * If the service_account_impersonation_url is provided, an additional\n   * step to exchange the external account GCP access token for a service\n   * account impersonated token is performed.\n   * @return A promise that resolves with the fresh GCP access tokens.\n   */\n  refreshAccessTokenAsync() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      // Retrieve the external credential.\n      const subjectToken = yield _this5.retrieveSubjectToken();\n      // Construct the STS credentials options.\n      const stsCredentialsOptions = {\n        grantType: STS_GRANT_TYPE,\n        audience: _this5.audience,\n        requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n        subjectToken,\n        subjectTokenType: _this5.subjectTokenType,\n        // generateAccessToken requires the provided access token to have\n        // scopes:\n        // https://www.googleapis.com/auth/iam or\n        // https://www.googleapis.com/auth/cloud-platform\n        // The new service account access token scopes will match the user\n        // provided ones.\n        scope: _this5.serviceAccountImpersonationUrl ? [DEFAULT_OAUTH_SCOPE] : _this5.getScopesArray()\n      };\n      // Exchange the external credentials for a GCP access token.\n      // Client auth is prioritized over passing the workforcePoolUserProject\n      // parameter for STS token exchange.\n      const additionalOptions = !_this5.clientAuth && _this5.workforcePoolUserProject ? {\n        userProject: _this5.workforcePoolUserProject\n      } : undefined;\n      const stsResponse = yield _this5.stsCredential.exchangeToken(stsCredentialsOptions, undefined, additionalOptions);\n      if (_this5.serviceAccountImpersonationUrl) {\n        _this5.cachedAccessToken = yield _this5.getImpersonatedAccessToken(stsResponse.access_token);\n      } else if (stsResponse.expires_in) {\n        // Save response in cached access token.\n        _this5.cachedAccessToken = {\n          access_token: stsResponse.access_token,\n          expiry_date: new Date().getTime() + stsResponse.expires_in * 1000,\n          res: stsResponse.res\n        };\n      } else {\n        // Save response in cached access token.\n        _this5.cachedAccessToken = {\n          access_token: stsResponse.access_token,\n          res: stsResponse.res\n        };\n      }\n      // Save credentials.\n      _this5.credentials = {};\n      Object.assign(_this5.credentials, _this5.cachedAccessToken);\n      delete _this5.credentials.res;\n      // Trigger tokens event to notify external listeners.\n      _this5.emit('tokens', {\n        refresh_token: null,\n        expiry_date: _this5.cachedAccessToken.expiry_date,\n        access_token: _this5.cachedAccessToken.access_token,\n        token_type: 'Bearer',\n        id_token: null\n      });\n      // Return the cached access token.\n      return _this5.cachedAccessToken;\n    })();\n  }\n  /**\n   * Returns the workload identity pool project number if it is determinable\n   * from the audience resource name.\n   * @param audience The STS audience used to determine the project number.\n   * @return The project number associated with the workload identity pool, if\n   *   this can be determined from the STS audience field. Otherwise, null is\n   *   returned.\n   */\n  getProjectNumber(audience) {\n    // STS audience pattern:\n    // //iam.googleapis.com/projects/$PROJECT_NUMBER/locations/...\n    const match = audience.match(/\\/projects\\/([^/]+)/);\n    if (!match) {\n      return null;\n    }\n    return match[1];\n  }\n  /**\n   * Exchanges an external account GCP access token for a service\n   * account impersonated access token using iamcredentials\n   * GenerateAccessToken API.\n   * @param token The access token to exchange for a service account access\n   *   token.\n   * @return A promise that resolves with the service account impersonated\n   *   credentials response.\n   */\n  getImpersonatedAccessToken(token) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const opts = {\n        url: _this6.serviceAccountImpersonationUrl,\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${token}`\n        },\n        data: {\n          scope: _this6.getScopesArray(),\n          lifetime: _this6.serviceAccountImpersonationLifetime + 's'\n        },\n        responseType: 'json'\n      };\n      const response = yield _this6.transporter.request(opts);\n      const successResponse = response.data;\n      return {\n        access_token: successResponse.accessToken,\n        // Convert from ISO format to timestamp.\n        expiry_date: new Date(successResponse.expireTime).getTime(),\n        res: response\n      };\n    })();\n  }\n  /**\n   * Returns whether the provided credentials are expired or not.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   * @param accessToken The credentials to check for expiration.\n   * @return Whether the credentials are expired or not.\n   */\n  isExpired(accessToken) {\n    const now = new Date().getTime();\n    return accessToken.expiry_date ? now >= accessToken.expiry_date - this.eagerRefreshThresholdMillis : false;\n  }\n  /**\n   * @return The list of scopes for the requested GCP access token.\n   */\n  getScopesArray() {\n    // Since scopes can be provided as string or array, the type should\n    // be normalized.\n    if (typeof this.scopes === 'string') {\n      return [this.scopes];\n    } else if (typeof this.scopes === 'undefined') {\n      return [DEFAULT_OAUTH_SCOPE];\n    } else {\n      return this.scopes;\n    }\n  }\n}\nexports.BaseExternalAccountClient = BaseExternalAccountClient;","map":{"version":3,"names":["_asyncToGenerator","require","default","Object","defineProperty","exports","value","BaseExternalAccountClient","CLOUD_RESOURCE_MANAGER","EXTERNAL_ACCOUNT_TYPE","EXPIRATION_TIME_OFFSET","stream","authclient_1","sts","STS_GRANT_TYPE","STS_REQUEST_TOKEN_TYPE","DEFAULT_OAUTH_SCOPE","DEFAULT_TOKEN_LIFESPAN","WORKFORCE_AUDIENCE_PATTERN","AuthClient","constructor","options","additionalOptions","_a","_b","type","Error","clientAuth","client_id","confidentialClientType","clientId","clientSecret","client_secret","undefined","stsCredential","StsCredentials","token_url","scopes","cachedAccessToken","audience","subjectTokenType","subject_token_type","quotaProjectId","quota_project_id","workforcePoolUserProject","workforce_pool_user_project","workforceAudiencePattern","RegExp","match","serviceAccountImpersonationUrl","service_account_impersonation_url","serviceAccountImpersonationLifetime","service_account_impersonation","token_lifetime_seconds","eagerRefreshThresholdMillis","forceRefreshOnFailure","projectId","projectNumber","getProjectNumber","getServiceAccountEmail","re","result","exec","groups","email","setCredentials","credentials","getAccessToken","_this","isExpired","refreshAccessTokenAsync","token","access_token","res","getRequestHeaders","_this2","accessTokenResponse","headers","Authorization","addSharedMetadataHeaders","request","opts","callback","requestAsync","then","r","e","response","getProjectId","_this3","transporter","url","responseType","data","retry","_this4","requestHeaders","statusCode","status","isReadableStream","config","Readable","isAuthErr","_this5","subjectToken","retrieveSubjectToken","stsCredentialsOptions","grantType","requestedTokenType","scope","getScopesArray","userProject","stsResponse","exchangeToken","getImpersonatedAccessToken","expires_in","expiry_date","Date","getTime","assign","emit","refresh_token","token_type","id_token","_this6","method","lifetime","successResponse","accessToken","expireTime","now"],"sources":["D:/graduation project/Graduation_Project-Dubbizel--main/Graduation_Project-Dubbizel--main/Dubbizel_Angular/node_modules/google-auth-library/build/src/auth/baseexternalclient.js"],"sourcesContent":["\"use strict\";\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseExternalAccountClient = exports.CLOUD_RESOURCE_MANAGER = exports.EXTERNAL_ACCOUNT_TYPE = exports.EXPIRATION_TIME_OFFSET = void 0;\nconst stream = require(\"stream\");\nconst authclient_1 = require(\"./authclient\");\nconst sts = require(\"./stscredentials\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */\nconst STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */\nconst STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/** The default OAuth scope to request when none is provided. */\nconst DEFAULT_OAUTH_SCOPE = 'https://www.googleapis.com/auth/cloud-platform';\n/** Default impersonated token lifespan in seconds.*/\nconst DEFAULT_TOKEN_LIFESPAN = 3600;\n/**\n * Offset to take into account network delays and server clock skews.\n */\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * The credentials JSON file type for external account clients.\n * There are 3 types of JSON configs:\n * 1. authorized_user => Google end user credential\n * 2. service_account => Google service account credential\n * 3. external_Account => non-GCP service (eg. AWS, Azure, K8s)\n */\nexports.EXTERNAL_ACCOUNT_TYPE = 'external_account';\n/** Cloud resource manager URL used to retrieve project information. */\nexports.CLOUD_RESOURCE_MANAGER = 'https://cloudresourcemanager.googleapis.com/v1/projects/';\n/** The workforce audience pattern. */\nconst WORKFORCE_AUDIENCE_PATTERN = '//iam.googleapis.com/locations/[^/]+/workforcePools/[^/]+/providers/.+';\n/**\n * Base external account client. This is used to instantiate AuthClients for\n * exchanging external account credentials for GCP access token and authorizing\n * requests to GCP APIs.\n * The base class implements common logic for exchanging various type of\n * external credentials for GCP access token. The logic of determining and\n * retrieving the external credential based on the environment and\n * credential_source will be left for the subclasses.\n */\nclass BaseExternalAccountClient extends authclient_1.AuthClient {\n    /**\n     * Instantiate a BaseExternalAccountClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     */\n    constructor(options, additionalOptions) {\n        var _a, _b;\n        super();\n        if (options.type !== exports.EXTERNAL_ACCOUNT_TYPE) {\n            throw new Error(`Expected \"${exports.EXTERNAL_ACCOUNT_TYPE}\" type but ` +\n                `received \"${options.type}\"`);\n        }\n        this.clientAuth = options.client_id\n            ? {\n                confidentialClientType: 'basic',\n                clientId: options.client_id,\n                clientSecret: options.client_secret,\n            }\n            : undefined;\n        this.stsCredential = new sts.StsCredentials(options.token_url, this.clientAuth);\n        // Default OAuth scope. This could be overridden via public property.\n        this.scopes = [DEFAULT_OAUTH_SCOPE];\n        this.cachedAccessToken = null;\n        this.audience = options.audience;\n        this.subjectTokenType = options.subject_token_type;\n        this.quotaProjectId = options.quota_project_id;\n        this.workforcePoolUserProject = options.workforce_pool_user_project;\n        const workforceAudiencePattern = new RegExp(WORKFORCE_AUDIENCE_PATTERN);\n        if (this.workforcePoolUserProject &&\n            !this.audience.match(workforceAudiencePattern)) {\n            throw new Error('workforcePoolUserProject should not be set for non-workforce pool ' +\n                'credentials.');\n        }\n        this.serviceAccountImpersonationUrl =\n            options.service_account_impersonation_url;\n        this.serviceAccountImpersonationLifetime =\n            (_b = (_a = options.service_account_impersonation) === null || _a === void 0 ? void 0 : _a.token_lifetime_seconds) !== null && _b !== void 0 ? _b : DEFAULT_TOKEN_LIFESPAN;\n        // As threshold could be zero,\n        // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n        // zero value.\n        if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {\n            this.eagerRefreshThresholdMillis = exports.EXPIRATION_TIME_OFFSET;\n        }\n        else {\n            this.eagerRefreshThresholdMillis = additionalOptions\n                .eagerRefreshThresholdMillis;\n        }\n        this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n        this.projectId = null;\n        this.projectNumber = this.getProjectNumber(this.audience);\n    }\n    /** The service account email to be impersonated, if available. */\n    getServiceAccountEmail() {\n        var _a;\n        if (this.serviceAccountImpersonationUrl) {\n            // Parse email from URL. The formal looks as follows:\n            // https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/name@project-id.iam.gserviceaccount.com:generateAccessToken\n            const re = /serviceAccounts\\/(?<email>[^:]+):generateAccessToken$/;\n            const result = re.exec(this.serviceAccountImpersonationUrl);\n            return ((_a = result === null || result === void 0 ? void 0 : result.groups) === null || _a === void 0 ? void 0 : _a.email) || null;\n        }\n        return null;\n    }\n    /**\n     * Provides a mechanism to inject GCP access tokens directly.\n     * When the provided credential expires, a new credential, using the\n     * external account options, is retrieved.\n     * @param credentials The Credentials object to set on the current client.\n     */\n    setCredentials(credentials) {\n        super.setCredentials(credentials);\n        this.cachedAccessToken = credentials;\n    }\n    /**\n     * @return A promise that resolves with the current GCP access token\n     *   response. If the current credential is expired, a new one is retrieved.\n     */\n    async getAccessToken() {\n        // If cached access token is unavailable or expired, force refresh.\n        if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {\n            await this.refreshAccessTokenAsync();\n        }\n        // Return GCP access token in GetAccessTokenResponse format.\n        return {\n            token: this.cachedAccessToken.access_token,\n            res: this.cachedAccessToken.res,\n        };\n    }\n    /**\n     * The main authentication interface. It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * The result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     */\n    async getRequestHeaders() {\n        const accessTokenResponse = await this.getAccessToken();\n        const headers = {\n            Authorization: `Bearer ${accessTokenResponse.token}`,\n        };\n        return this.addSharedMetadataHeaders(headers);\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then(r => callback(null, r), e => {\n                return callback(e, e.response);\n            });\n        }\n        else {\n            return this.requestAsync(opts);\n        }\n    }\n    /**\n     * @return A promise that resolves with the project ID corresponding to the\n     *   current workload identity pool or current workforce pool if\n     *   determinable. For workforce pool credential, it returns the project ID\n     *   corresponding to the workforcePoolUserProject.\n     *   This is introduced to match the current pattern of using the Auth\n     *   library:\n     *   const projectId = await auth.getProjectId();\n     *   const url = `https://dns.googleapis.com/dns/v1/projects/${projectId}`;\n     *   const res = await client.request({ url });\n     *   The resource may not have permission\n     *   (resourcemanager.projects.get) to call this API or the required\n     *   scopes may not be selected:\n     *   https://cloud.google.com/resource-manager/reference/rest/v1/projects/get#authorization-scopes\n     */\n    async getProjectId() {\n        const projectNumber = this.projectNumber || this.workforcePoolUserProject;\n        if (this.projectId) {\n            // Return previously determined project ID.\n            return this.projectId;\n        }\n        else if (projectNumber) {\n            // Preferable not to use request() to avoid retrial policies.\n            const headers = await this.getRequestHeaders();\n            const response = await this.transporter.request({\n                headers,\n                url: `${exports.CLOUD_RESOURCE_MANAGER}${projectNumber}`,\n                responseType: 'json',\n            });\n            this.projectId = response.data.projectId;\n            return this.projectId;\n        }\n        return null;\n    }\n    /**\n     * Authenticates the provided HTTP request, processes it and resolves with the\n     * returned response.\n     * @param opts The HTTP request options.\n     * @param retry Whether the current attempt is a retry after a failed attempt.\n     * @return A promise that resolves with the successful response.\n     */\n    async requestAsync(opts, retry = false) {\n        let response;\n        try {\n            const requestHeaders = await this.getRequestHeaders();\n            opts.headers = opts.headers || {};\n            if (requestHeaders && requestHeaders['x-goog-user-project']) {\n                opts.headers['x-goog-user-project'] =\n                    requestHeaders['x-goog-user-project'];\n            }\n            if (requestHeaders && requestHeaders.Authorization) {\n                opts.headers.Authorization = requestHeaders.Authorization;\n            }\n            response = await this.transporter.request(opts);\n        }\n        catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - forceRefreshOnFailure is true\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!retry &&\n                    isAuthErr &&\n                    !isReadableStream &&\n                    this.forceRefreshOnFailure) {\n                    await this.refreshAccessTokenAsync();\n                    return await this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return response;\n    }\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * External credentials are exchanged for GCP access tokens via the token\n     * exchange endpoint and other settings provided in the client options\n     * object.\n     * If the service_account_impersonation_url is provided, an additional\n     * step to exchange the external account GCP access token for a service\n     * account impersonated token is performed.\n     * @return A promise that resolves with the fresh GCP access tokens.\n     */\n    async refreshAccessTokenAsync() {\n        // Retrieve the external credential.\n        const subjectToken = await this.retrieveSubjectToken();\n        // Construct the STS credentials options.\n        const stsCredentialsOptions = {\n            grantType: STS_GRANT_TYPE,\n            audience: this.audience,\n            requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n            subjectToken,\n            subjectTokenType: this.subjectTokenType,\n            // generateAccessToken requires the provided access token to have\n            // scopes:\n            // https://www.googleapis.com/auth/iam or\n            // https://www.googleapis.com/auth/cloud-platform\n            // The new service account access token scopes will match the user\n            // provided ones.\n            scope: this.serviceAccountImpersonationUrl\n                ? [DEFAULT_OAUTH_SCOPE]\n                : this.getScopesArray(),\n        };\n        // Exchange the external credentials for a GCP access token.\n        // Client auth is prioritized over passing the workforcePoolUserProject\n        // parameter for STS token exchange.\n        const additionalOptions = !this.clientAuth && this.workforcePoolUserProject\n            ? { userProject: this.workforcePoolUserProject }\n            : undefined;\n        const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, undefined, additionalOptions);\n        if (this.serviceAccountImpersonationUrl) {\n            this.cachedAccessToken = await this.getImpersonatedAccessToken(stsResponse.access_token);\n        }\n        else if (stsResponse.expires_in) {\n            // Save response in cached access token.\n            this.cachedAccessToken = {\n                access_token: stsResponse.access_token,\n                expiry_date: new Date().getTime() + stsResponse.expires_in * 1000,\n                res: stsResponse.res,\n            };\n        }\n        else {\n            // Save response in cached access token.\n            this.cachedAccessToken = {\n                access_token: stsResponse.access_token,\n                res: stsResponse.res,\n            };\n        }\n        // Save credentials.\n        this.credentials = {};\n        Object.assign(this.credentials, this.cachedAccessToken);\n        delete this.credentials.res;\n        // Trigger tokens event to notify external listeners.\n        this.emit('tokens', {\n            refresh_token: null,\n            expiry_date: this.cachedAccessToken.expiry_date,\n            access_token: this.cachedAccessToken.access_token,\n            token_type: 'Bearer',\n            id_token: null,\n        });\n        // Return the cached access token.\n        return this.cachedAccessToken;\n    }\n    /**\n     * Returns the workload identity pool project number if it is determinable\n     * from the audience resource name.\n     * @param audience The STS audience used to determine the project number.\n     * @return The project number associated with the workload identity pool, if\n     *   this can be determined from the STS audience field. Otherwise, null is\n     *   returned.\n     */\n    getProjectNumber(audience) {\n        // STS audience pattern:\n        // //iam.googleapis.com/projects/$PROJECT_NUMBER/locations/...\n        const match = audience.match(/\\/projects\\/([^/]+)/);\n        if (!match) {\n            return null;\n        }\n        return match[1];\n    }\n    /**\n     * Exchanges an external account GCP access token for a service\n     * account impersonated access token using iamcredentials\n     * GenerateAccessToken API.\n     * @param token The access token to exchange for a service account access\n     *   token.\n     * @return A promise that resolves with the service account impersonated\n     *   credentials response.\n     */\n    async getImpersonatedAccessToken(token) {\n        const opts = {\n            url: this.serviceAccountImpersonationUrl,\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                Authorization: `Bearer ${token}`,\n            },\n            data: {\n                scope: this.getScopesArray(),\n                lifetime: this.serviceAccountImpersonationLifetime + 's',\n            },\n            responseType: 'json',\n        };\n        const response = await this.transporter.request(opts);\n        const successResponse = response.data;\n        return {\n            access_token: successResponse.accessToken,\n            // Convert from ISO format to timestamp.\n            expiry_date: new Date(successResponse.expireTime).getTime(),\n            res: response,\n        };\n    }\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param accessToken The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */\n    isExpired(accessToken) {\n        const now = new Date().getTime();\n        return accessToken.expiry_date\n            ? now >= accessToken.expiry_date - this.eagerRefreshThresholdMillis\n            : false;\n    }\n    /**\n     * @return The list of scopes for the requested GCP access token.\n     */\n    getScopesArray() {\n        // Since scopes can be provided as string or array, the type should\n        // be normalized.\n        if (typeof this.scopes === 'string') {\n            return [this.scopes];\n        }\n        else if (typeof this.scopes === 'undefined') {\n            return [DEFAULT_OAUTH_SCOPE];\n        }\n        else {\n            return this.scopes;\n        }\n    }\n}\nexports.BaseExternalAccountClient = BaseExternalAccountClient;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}