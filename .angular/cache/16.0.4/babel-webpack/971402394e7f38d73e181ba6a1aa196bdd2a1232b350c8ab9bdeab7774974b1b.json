{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default('https-proxy-agent:parse-proxy-response');\nfunction parseProxyResponse(socket) {\n  return new Promise((resolve, reject) => {\n    // we need to buffer any HTTP traffic that happens with the proxy before we get\n    // the CONNECT response, so that if the response is anything other than an \"200\"\n    // response code, then we can re-play the \"data\" events on the socket once the\n    // HTTP parser is hooked up...\n    let buffersLength = 0;\n    const buffers = [];\n    function read() {\n      const b = socket.read();\n      if (b) ondata(b);else socket.once('readable', read);\n    }\n    function cleanup() {\n      socket.removeListener('end', onend);\n      socket.removeListener('error', onerror);\n      socket.removeListener('close', onclose);\n      socket.removeListener('readable', read);\n    }\n    function onclose(err) {\n      debug('onclose had error %o', err);\n    }\n    function onend() {\n      debug('onend');\n    }\n    function onerror(err) {\n      cleanup();\n      debug('onerror %o', err);\n      reject(err);\n    }\n    function ondata(b) {\n      buffers.push(b);\n      buffersLength += b.length;\n      const buffered = Buffer.concat(buffers, buffersLength);\n      const endOfHeaders = buffered.indexOf('\\r\\n\\r\\n');\n      if (endOfHeaders === -1) {\n        // keep buffering\n        debug('have not received end of HTTP headers yet...');\n        read();\n        return;\n      }\n      const firstLine = buffered.toString('ascii', 0, buffered.indexOf('\\r\\n'));\n      const statusCode = +firstLine.split(' ')[1];\n      debug('got proxy server response: %o', firstLine);\n      resolve({\n        statusCode,\n        buffered\n      });\n    }\n    socket.on('error', onerror);\n    socket.on('close', onclose);\n    socket.on('end', onend);\n    read();\n  });\n}\nexports.default = parseProxyResponse;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","debug_1","require","debug","default","parseProxyResponse","socket","Promise","resolve","reject","buffersLength","buffers","read","b","ondata","once","cleanup","removeListener","onend","onerror","onclose","err","push","length","buffered","Buffer","concat","endOfHeaders","indexOf","firstLine","toString","statusCode","split","on"],"sources":["D:/graduation project/Graduation_Project-Dubbizel--main/Graduation_Project-Dubbizel--main/Dubbizel_Angular/node_modules/https-proxy-agent/dist/parse-proxy-response.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default('https-proxy-agent:parse-proxy-response');\nfunction parseProxyResponse(socket) {\n    return new Promise((resolve, reject) => {\n        // we need to buffer any HTTP traffic that happens with the proxy before we get\n        // the CONNECT response, so that if the response is anything other than an \"200\"\n        // response code, then we can re-play the \"data\" events on the socket once the\n        // HTTP parser is hooked up...\n        let buffersLength = 0;\n        const buffers = [];\n        function read() {\n            const b = socket.read();\n            if (b)\n                ondata(b);\n            else\n                socket.once('readable', read);\n        }\n        function cleanup() {\n            socket.removeListener('end', onend);\n            socket.removeListener('error', onerror);\n            socket.removeListener('close', onclose);\n            socket.removeListener('readable', read);\n        }\n        function onclose(err) {\n            debug('onclose had error %o', err);\n        }\n        function onend() {\n            debug('onend');\n        }\n        function onerror(err) {\n            cleanup();\n            debug('onerror %o', err);\n            reject(err);\n        }\n        function ondata(b) {\n            buffers.push(b);\n            buffersLength += b.length;\n            const buffered = Buffer.concat(buffers, buffersLength);\n            const endOfHeaders = buffered.indexOf('\\r\\n\\r\\n');\n            if (endOfHeaders === -1) {\n                // keep buffering\n                debug('have not received end of HTTP headers yet...');\n                read();\n                return;\n            }\n            const firstLine = buffered.toString('ascii', 0, buffered.indexOf('\\r\\n'));\n            const statusCode = +firstLine.split(' ')[1];\n            debug('got proxy server response: %o', firstLine);\n            resolve({\n                statusCode,\n                buffered\n            });\n        }\n        socket.on('error', onerror);\n        socket.on('close', onclose);\n        socket.on('end', onend);\n        read();\n    });\n}\nexports.default = parseProxyResponse;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}