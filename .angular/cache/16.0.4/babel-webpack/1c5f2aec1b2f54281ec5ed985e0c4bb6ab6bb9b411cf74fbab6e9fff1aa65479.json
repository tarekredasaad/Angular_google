{"ast":null,"code":"\"use strict\";\n\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar _asyncToGenerator = require(\"D:/graduation project/Graduation_Project-Dubbizel--main/Graduation_Project-Dubbizel--main/Dubbizel_Angular/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GoogleAuth = exports.CLOUD_SDK_CLIENT_ID = void 0;\nconst child_process_1 = require(\"child_process\");\nconst fs = require(\"fs\");\nconst gcpMetadata = require(\"gcp-metadata\");\nconst os = require(\"os\");\nconst path = require(\"path\");\nconst crypto_1 = require(\"../crypto/crypto\");\nconst transporters_1 = require(\"../transporters\");\nconst computeclient_1 = require(\"./computeclient\");\nconst idtokenclient_1 = require(\"./idtokenclient\");\nconst envDetect_1 = require(\"./envDetect\");\nconst jwtclient_1 = require(\"./jwtclient\");\nconst refreshclient_1 = require(\"./refreshclient\");\nconst impersonated_1 = require(\"./impersonated\");\nconst externalclient_1 = require(\"./externalclient\");\nconst baseexternalclient_1 = require(\"./baseexternalclient\");\nconst externalAccountAuthorizedUserClient_1 = require(\"./externalAccountAuthorizedUserClient\");\nexports.CLOUD_SDK_CLIENT_ID = '764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com';\nconst GoogleAuthExceptionMessages = {\n  NO_PROJECT_ID_FOUND: 'Unable to detect a Project Id in the current environment. \\n' + 'To learn more about authentication and Google APIs, visit: \\n' + 'https://cloud.google.com/docs/authentication/getting-started'\n};\nclass GoogleAuth {\n  // Note:  this properly is only public to satisify unit tests.\n  // https://github.com/Microsoft/TypeScript/issues/5228\n  get isGCE() {\n    return this.checkIsGCE;\n  }\n  constructor(opts) {\n    /**\n     * Caches a value indicating whether the auth layer is running on Google\n     * Compute Engine.\n     * @private\n     */\n    this.checkIsGCE = undefined;\n    // To save the contents of the JSON credential file\n    this.jsonContent = null;\n    this.cachedCredential = null;\n    opts = opts || {};\n    this._cachedProjectId = opts.projectId || null;\n    this.cachedCredential = opts.authClient || null;\n    this.keyFilename = opts.keyFilename || opts.keyFile;\n    this.scopes = opts.scopes;\n    this.jsonContent = opts.credentials || null;\n    this.clientOptions = opts.clientOptions;\n  }\n  // GAPIC client libraries should always use self-signed JWTs. The following\n  // variables are set on the JWT client in order to indicate the type of library,\n  // and sign the JWT with the correct audience and scopes (if not supplied).\n  setGapicJWTValues(client) {\n    client.defaultServicePath = this.defaultServicePath;\n    client.useJWTAccessWithScope = this.useJWTAccessWithScope;\n    client.defaultScopes = this.defaultScopes;\n  }\n  getProjectId(callback) {\n    if (callback) {\n      this.getProjectIdAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getProjectIdAsync();\n    }\n  }\n  /**\n   * A temporary method for internal `getProjectId` usages where `null` is\n   * acceptable. In a future major release, `getProjectId` should return `null`\n   * (as the `Promise<string | null>` base signature describes) and this private\n   * method should be removed.\n   *\n   * @returns Promise that resolves with project id (or `null`)\n   */\n  getProjectIdOptional() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        return yield _this.getProjectId();\n      } catch (e) {\n        if (e instanceof Error && e.message === GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND) {\n          return null;\n        } else {\n          throw e;\n        }\n      }\n    })();\n  }\n  /*\n   * A private method for finding and caching a projectId.\n   *\n   * Supports environments in order of precedence:\n   * - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\n   * - GOOGLE_APPLICATION_CREDENTIALS JSON file\n   * - Cloud SDK: `gcloud config config-helper --format json`\n   * - GCE project ID from metadata server\n   *\n   * @returns projectId\n   */\n  findAndCacheProjectId() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      let projectId = null;\n      projectId || (projectId = yield _this2.getProductionProjectId());\n      projectId || (projectId = yield _this2.getFileProjectId());\n      projectId || (projectId = yield _this2.getDefaultServiceProjectId());\n      projectId || (projectId = yield _this2.getGCEProjectId());\n      projectId || (projectId = yield _this2.getExternalAccountClientProjectId());\n      if (projectId) {\n        _this2._cachedProjectId = projectId;\n        return projectId;\n      } else {\n        throw new Error(GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND);\n      }\n    })();\n  }\n  getProjectIdAsync() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (_this3._cachedProjectId) {\n        return _this3._cachedProjectId;\n      }\n      if (!_this3._findProjectIdPromise) {\n        _this3._findProjectIdPromise = _this3.findAndCacheProjectId();\n      }\n      return _this3._findProjectIdPromise;\n    })();\n  }\n  /**\n   * @returns Any scopes (user-specified or default scopes specified by the\n   *   client library) that need to be set on the current Auth client.\n   */\n  getAnyScopes() {\n    return this.scopes || this.defaultScopes;\n  }\n  getApplicationDefault(optionsOrCallback = {}, callback) {\n    let options;\n    if (typeof optionsOrCallback === 'function') {\n      callback = optionsOrCallback;\n    } else {\n      options = optionsOrCallback;\n    }\n    if (callback) {\n      this.getApplicationDefaultAsync(options).then(r => callback(null, r.credential, r.projectId), callback);\n    } else {\n      return this.getApplicationDefaultAsync(options);\n    }\n  }\n  getApplicationDefaultAsync(options = {}) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      // If we've already got a cached credential, return it.\n      // This will also preserve one's configured quota project, in case they\n      // set one directly on the credential previously.\n      if (_this4.cachedCredential) {\n        return yield _this4.prepareAndCacheADC(_this4.cachedCredential);\n      }\n      // Since this is a 'new' ADC to cache we will use the environment variable\n      // if it's available. We prefer this value over the value from ADC.\n      const quotaProjectIdOverride = process.env['GOOGLE_CLOUD_QUOTA_PROJECT'];\n      let credential;\n      // Check for the existence of a local environment variable pointing to the\n      // location of the credential file. This is typically used in local\n      // developer scenarios.\n      credential = yield _this4._tryGetApplicationCredentialsFromEnvironmentVariable(options);\n      if (credential) {\n        if (credential instanceof jwtclient_1.JWT) {\n          credential.scopes = _this4.scopes;\n        } else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\n          credential.scopes = _this4.getAnyScopes();\n        }\n        return yield _this4.prepareAndCacheADC(credential, quotaProjectIdOverride);\n      }\n      // Look in the well-known credential file location.\n      credential = yield _this4._tryGetApplicationCredentialsFromWellKnownFile(options);\n      if (credential) {\n        if (credential instanceof jwtclient_1.JWT) {\n          credential.scopes = _this4.scopes;\n        } else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\n          credential.scopes = _this4.getAnyScopes();\n        }\n        return yield _this4.prepareAndCacheADC(credential, quotaProjectIdOverride);\n      }\n      // Determine if we're running on GCE.\n      let isGCE;\n      try {\n        isGCE = yield _this4._checkIsGCE();\n      } catch (e) {\n        if (e instanceof Error) {\n          e.message = `Unexpected error determining execution environment: ${e.message}`;\n        }\n        throw e;\n      }\n      if (!isGCE) {\n        // We failed to find the default credentials. Bail out with an error.\n        throw new Error('Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.');\n      }\n      // For GCE, just return a default ComputeClient. It will take care of\n      // the rest.\n      options.scopes = _this4.getAnyScopes();\n      return yield _this4.prepareAndCacheADC(new computeclient_1.Compute(options), quotaProjectIdOverride);\n    })();\n  }\n  prepareAndCacheADC(credential, quotaProjectIdOverride) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const projectId = yield _this5.getProjectIdOptional();\n      if (quotaProjectIdOverride) {\n        credential.quotaProjectId = quotaProjectIdOverride;\n      }\n      _this5.cachedCredential = credential;\n      return {\n        credential,\n        projectId\n      };\n    })();\n  }\n  /**\n   * Determines whether the auth layer is running on Google Compute Engine.\n   * @returns A promise that resolves with the boolean.\n   * @api private\n   */\n  _checkIsGCE() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      if (_this6.checkIsGCE === undefined) {\n        _this6.checkIsGCE = yield gcpMetadata.isAvailable();\n      }\n      return _this6.checkIsGCE;\n    })();\n  }\n  /**\n   * Attempts to load default credentials from the environment variable path..\n   * @returns Promise that resolves with the OAuth2Client or null.\n   * @api private\n   */\n  _tryGetApplicationCredentialsFromEnvironmentVariable(options) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const credentialsPath = process.env['GOOGLE_APPLICATION_CREDENTIALS'] || process.env['google_application_credentials'];\n      if (!credentialsPath || credentialsPath.length === 0) {\n        return null;\n      }\n      try {\n        return _this7._getApplicationCredentialsFromFilePath(credentialsPath, options);\n      } catch (e) {\n        if (e instanceof Error) {\n          e.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ${e.message}`;\n        }\n        throw e;\n      }\n    })();\n  }\n  /**\n   * Attempts to load default credentials from a well-known file location\n   * @return Promise that resolves with the OAuth2Client or null.\n   * @api private\n   */\n  _tryGetApplicationCredentialsFromWellKnownFile(options) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      // First, figure out the location of the file, depending upon the OS type.\n      let location = null;\n      if (_this8._isWindows()) {\n        // Windows\n        location = process.env['APPDATA'];\n      } else {\n        // Linux or Mac\n        const home = process.env['HOME'];\n        if (home) {\n          location = path.join(home, '.config');\n        }\n      }\n      // If we found the root path, expand it.\n      if (location) {\n        location = path.join(location, 'gcloud', 'application_default_credentials.json');\n        if (!fs.existsSync(location)) {\n          location = null;\n        }\n      }\n      // The file does not exist.\n      if (!location) {\n        return null;\n      }\n      // The file seems to exist. Try to use it.\n      const client = yield _this8._getApplicationCredentialsFromFilePath(location, options);\n      return client;\n    })();\n  }\n  /**\n   * Attempts to load default credentials from a file at the given path..\n   * @param filePath The path to the file to read.\n   * @returns Promise that resolves with the OAuth2Client\n   * @api private\n   */\n  _getApplicationCredentialsFromFilePath(filePath, options = {}) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      // Make sure the path looks like a string.\n      if (!filePath || filePath.length === 0) {\n        throw new Error('The file path is invalid.');\n      }\n      // Make sure there is a file at the path. lstatSync will throw if there is\n      // nothing there.\n      try {\n        // Resolve path to actual file in case of symlink. Expect a thrown error\n        // if not resolvable.\n        filePath = fs.realpathSync(filePath);\n        if (!fs.lstatSync(filePath).isFile()) {\n          throw new Error();\n        }\n      } catch (err) {\n        if (err instanceof Error) {\n          err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\n        }\n        throw err;\n      }\n      // Now open a read stream on the file, and parse it.\n      const readStream = fs.createReadStream(filePath);\n      return _this9.fromStream(readStream, options);\n    })();\n  }\n  /**\n   * Create a credentials instance using a given impersonated input options.\n   * @param json The impersonated input object.\n   * @returns JWT or UserRefresh Client with data\n   */\n  fromImpersonatedJSON(json) {\n    var _a, _b, _c, _d;\n    if (!json) {\n      throw new Error('Must pass in a JSON object containing an  impersonated refresh token');\n    }\n    if (json.type !== impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {\n      throw new Error(`The incoming JSON object does not have the \"${impersonated_1.IMPERSONATED_ACCOUNT_TYPE}\" type`);\n    }\n    if (!json.source_credentials) {\n      throw new Error('The incoming JSON object does not contain a source_credentials field');\n    }\n    if (!json.service_account_impersonation_url) {\n      throw new Error('The incoming JSON object does not contain a service_account_impersonation_url field');\n    }\n    // Create source client for impersonation\n    const sourceClient = new refreshclient_1.UserRefreshClient(json.source_credentials.client_id, json.source_credentials.client_secret, json.source_credentials.refresh_token);\n    // Extreact service account from service_account_impersonation_url\n    const targetPrincipal = (_b = (_a = /(?<target>[^/]+):generateAccessToken$/.exec(json.service_account_impersonation_url)) === null || _a === void 0 ? void 0 : _a.groups) === null || _b === void 0 ? void 0 : _b.target;\n    if (!targetPrincipal) {\n      throw new RangeError(`Cannot extract target principal from ${json.service_account_impersonation_url}`);\n    }\n    const targetScopes = (_c = this.getAnyScopes()) !== null && _c !== void 0 ? _c : [];\n    const client = new impersonated_1.Impersonated({\n      delegates: (_d = json.delegates) !== null && _d !== void 0 ? _d : [],\n      sourceClient: sourceClient,\n      targetPrincipal: targetPrincipal,\n      targetScopes: Array.isArray(targetScopes) ? targetScopes : [targetScopes]\n    });\n    return client;\n  }\n  /**\n   * Create a credentials instance using the given input options.\n   * @param json The input object.\n   * @param options The JWT or UserRefresh options for the client\n   * @returns JWT or UserRefresh Client with data\n   */\n  fromJSON(json, options = {}) {\n    let client;\n    options = options || {};\n    if (json.type === refreshclient_1.USER_REFRESH_ACCOUNT_TYPE) {\n      client = new refreshclient_1.UserRefreshClient(options);\n      client.fromJSON(json);\n    } else if (json.type === impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {\n      client = this.fromImpersonatedJSON(json);\n    } else if (json.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n      client = externalclient_1.ExternalAccountClient.fromJSON(json, options);\n      client.scopes = this.getAnyScopes();\n    } else if (json.type === externalAccountAuthorizedUserClient_1.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE) {\n      client = new externalAccountAuthorizedUserClient_1.ExternalAccountAuthorizedUserClient(json, options);\n    } else {\n      options.scopes = this.scopes;\n      client = new jwtclient_1.JWT(options);\n      this.setGapicJWTValues(client);\n      client.fromJSON(json);\n    }\n    return client;\n  }\n  /**\n   * Return a JWT or UserRefreshClient from JavaScript object, caching both the\n   * object used to instantiate and the client.\n   * @param json The input object.\n   * @param options The JWT or UserRefresh options for the client\n   * @returns JWT or UserRefresh Client with data\n   */\n  _cacheClientFromJSON(json, options) {\n    const client = this.fromJSON(json, options);\n    // cache both raw data used to instantiate client and client itself.\n    this.jsonContent = json;\n    this.cachedCredential = client;\n    return client;\n  }\n  fromStream(inputStream, optionsOrCallback = {}, callback) {\n    let options = {};\n    if (typeof optionsOrCallback === 'function') {\n      callback = optionsOrCallback;\n    } else {\n      options = optionsOrCallback;\n    }\n    if (callback) {\n      this.fromStreamAsync(inputStream, options).then(r => callback(null, r), callback);\n    } else {\n      return this.fromStreamAsync(inputStream, options);\n    }\n  }\n  fromStreamAsync(inputStream, options) {\n    return new Promise((resolve, reject) => {\n      if (!inputStream) {\n        throw new Error('Must pass in a stream containing the Google auth settings.');\n      }\n      let s = '';\n      inputStream.setEncoding('utf8').on('error', reject).on('data', chunk => s += chunk).on('end', () => {\n        try {\n          try {\n            const data = JSON.parse(s);\n            const r = this._cacheClientFromJSON(data, options);\n            return resolve(r);\n          } catch (err) {\n            // If we failed parsing this.keyFileName, assume that it\n            // is a PEM or p12 certificate:\n            if (!this.keyFilename) throw err;\n            const client = new jwtclient_1.JWT({\n              ...this.clientOptions,\n              keyFile: this.keyFilename\n            });\n            this.cachedCredential = client;\n            this.setGapicJWTValues(client);\n            return resolve(client);\n          }\n        } catch (err) {\n          return reject(err);\n        }\n      });\n    });\n  }\n  /**\n   * Create a credentials instance using the given API key string.\n   * @param apiKey The API key string\n   * @param options An optional options object.\n   * @returns A JWT loaded from the key\n   */\n  fromAPIKey(apiKey, options) {\n    options = options || {};\n    const client = new jwtclient_1.JWT(options);\n    client.fromAPIKey(apiKey);\n    return client;\n  }\n  /**\n   * Determines whether the current operating system is Windows.\n   * @api private\n   */\n  _isWindows() {\n    const sys = os.platform();\n    if (sys && sys.length >= 3) {\n      if (sys.substring(0, 3).toLowerCase() === 'win') {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Run the Google Cloud SDK command that prints the default project ID\n   */\n  getDefaultServiceProjectId() {\n    return _asyncToGenerator(function* () {\n      return new Promise(resolve => {\n        (0, child_process_1.exec)('gcloud config config-helper --format json', (err, stdout) => {\n          if (!err && stdout) {\n            try {\n              const projectId = JSON.parse(stdout).configuration.properties.core.project;\n              resolve(projectId);\n              return;\n            } catch (e) {\n              // ignore errors\n            }\n          }\n          resolve(null);\n        });\n      });\n    })();\n  }\n  /**\n   * Loads the project id from environment variables.\n   * @api private\n   */\n  getProductionProjectId() {\n    return process.env['GCLOUD_PROJECT'] || process.env['GOOGLE_CLOUD_PROJECT'] || process.env['gcloud_project'] || process.env['google_cloud_project'];\n  }\n  /**\n   * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\n   * @api private\n   */\n  getFileProjectId() {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      if (_this10.cachedCredential) {\n        // Try to read the project ID from the cached credentials file\n        return _this10.cachedCredential.projectId;\n      }\n      // Ensure the projectId is loaded from the keyFile if available.\n      if (_this10.keyFilename) {\n        const creds = yield _this10.getClient();\n        if (creds && creds.projectId) {\n          return creds.projectId;\n        }\n      }\n      // Try to load a credentials file and read its project ID\n      const r = yield _this10._tryGetApplicationCredentialsFromEnvironmentVariable();\n      if (r) {\n        return r.projectId;\n      } else {\n        return null;\n      }\n    })();\n  }\n  /**\n   * Gets the project ID from external account client if available.\n   */\n  getExternalAccountClientProjectId() {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this11.jsonContent || _this11.jsonContent.type !== baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n        return null;\n      }\n      const creds = yield _this11.getClient();\n      // Do not suppress the underlying error, as the error could contain helpful\n      // information for debugging and fixing. This is especially true for\n      // external account creds as in order to get the project ID, the following\n      // operations have to succeed:\n      // 1. Valid credentials file should be supplied.\n      // 2. Ability to retrieve access tokens from STS token exchange API.\n      // 3. Ability to exchange for service account impersonated credentials (if\n      //    enabled).\n      // 4. Ability to get project info using the access token from step 2 or 3.\n      // Without surfacing the error, it is harder for developers to determine\n      // which step went wrong.\n      return yield creds.getProjectId();\n    })();\n  }\n  /**\n   * Gets the Compute Engine project ID if it can be inferred.\n   */\n  getGCEProjectId() {\n    return _asyncToGenerator(function* () {\n      try {\n        const r = yield gcpMetadata.project('project-id');\n        return r;\n      } catch (e) {\n        // Ignore any errors\n        return null;\n      }\n    })();\n  }\n  getCredentials(callback) {\n    if (callback) {\n      this.getCredentialsAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getCredentialsAsync();\n    }\n  }\n  getCredentialsAsync() {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const client = yield _this12.getClient();\n      if (client instanceof baseexternalclient_1.BaseExternalAccountClient) {\n        const serviceAccountEmail = client.getServiceAccountEmail();\n        if (serviceAccountEmail) {\n          return {\n            client_email: serviceAccountEmail\n          };\n        }\n      }\n      if (_this12.jsonContent) {\n        const credential = {\n          client_email: _this12.jsonContent.client_email,\n          private_key: _this12.jsonContent.private_key\n        };\n        return credential;\n      }\n      const isGCE = yield _this12._checkIsGCE();\n      if (!isGCE) {\n        throw new Error('Unknown error.');\n      }\n      // For GCE, return the service account details from the metadata server\n      // NOTE: The trailing '/' at the end of service-accounts/ is very important!\n      // The GCF metadata server doesn't respect querystring params if this / is\n      // not included.\n      const data = yield gcpMetadata.instance({\n        property: 'service-accounts/',\n        params: {\n          recursive: 'true'\n        }\n      });\n      if (!data || !data.default || !data.default.email) {\n        throw new Error('Failure from metadata server.');\n      }\n      return {\n        client_email: data.default.email\n      };\n    })();\n  }\n  /**\n   * Automatically obtain a client based on the provided configuration.  If no\n   * options were passed, use Application Default Credentials.\n   */\n  getClient() {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this13.cachedCredential) {\n        if (_this13.jsonContent) {\n          _this13._cacheClientFromJSON(_this13.jsonContent, _this13.clientOptions);\n        } else if (_this13.keyFilename) {\n          const filePath = path.resolve(_this13.keyFilename);\n          const stream = fs.createReadStream(filePath);\n          yield _this13.fromStreamAsync(stream, _this13.clientOptions);\n        } else {\n          yield _this13.getApplicationDefaultAsync(_this13.clientOptions);\n        }\n      }\n      return _this13.cachedCredential;\n    })();\n  }\n  /**\n   * Creates a client which will fetch an ID token for authorization.\n   * @param targetAudience the audience for the fetched ID token.\n   * @returns IdTokenClient for making HTTP calls authenticated with ID tokens.\n   */\n  getIdTokenClient(targetAudience) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      const client = yield _this14.getClient();\n      if (!('fetchIdToken' in client)) {\n        throw new Error('Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.');\n      }\n      return new idtokenclient_1.IdTokenClient({\n        targetAudience,\n        idTokenProvider: client\n      });\n    })();\n  }\n  /**\n   * Automatically obtain application default credentials, and return\n   * an access token for making requests.\n   */\n  getAccessToken() {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const client = yield _this15.getClient();\n      return (yield client.getAccessToken()).token;\n    })();\n  }\n  /**\n   * Obtain the HTTP headers that will provide authorization for a given\n   * request.\n   */\n  getRequestHeaders(url) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const client = yield _this16.getClient();\n      return client.getRequestHeaders(url);\n    })();\n  }\n  /**\n   * Obtain credentials for a request, then attach the appropriate headers to\n   * the request options.\n   * @param opts Axios or Request options on which to attach the headers\n   */\n  authorizeRequest(opts) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      opts = opts || {};\n      const url = opts.url || opts.uri;\n      const client = yield _this17.getClient();\n      const headers = yield client.getRequestHeaders(url);\n      opts.headers = Object.assign(opts.headers || {}, headers);\n      return opts;\n    })();\n  }\n  /**\n   * Automatically obtain application default credentials, and make an\n   * HTTP request using the given options.\n   * @param opts Axios request options for the HTTP request.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  request(opts) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      const client = yield _this18.getClient();\n      return client.request(opts);\n    })();\n  }\n  /**\n   * Determine the compute environment in which the code is running.\n   */\n  getEnv() {\n    return (0, envDetect_1.getEnv)();\n  }\n  /**\n   * Sign the given data with the current private key, or go out\n   * to the IAM API to sign it.\n   * @param data The data to be signed.\n   */\n  sign(data) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      const client = yield _this19.getClient();\n      const crypto = (0, crypto_1.createCrypto)();\n      if (client instanceof jwtclient_1.JWT && client.key) {\n        const sign = yield crypto.sign(client.key, data);\n        return sign;\n      }\n      const creds = yield _this19.getCredentials();\n      if (!creds.client_email) {\n        throw new Error('Cannot sign data without `client_email`.');\n      }\n      return _this19.signBlob(crypto, creds.client_email, data);\n    })();\n  }\n  signBlob(crypto, emailOrUniqueId, data) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      const url = 'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/' + `${emailOrUniqueId}:signBlob`;\n      const res = yield _this20.request({\n        method: 'POST',\n        url,\n        data: {\n          payload: crypto.encodeBase64StringUtf8(data)\n        }\n      });\n      return res.data.signedBlob;\n    })();\n  }\n}\nexports.GoogleAuth = GoogleAuth;\n/**\n * Export DefaultTransporter as a static property of the class.\n */\nGoogleAuth.DefaultTransporter = transporters_1.DefaultTransporter;","map":{"version":3,"names":["_asyncToGenerator","require","default","Object","defineProperty","exports","value","GoogleAuth","CLOUD_SDK_CLIENT_ID","child_process_1","fs","gcpMetadata","os","path","crypto_1","transporters_1","computeclient_1","idtokenclient_1","envDetect_1","jwtclient_1","refreshclient_1","impersonated_1","externalclient_1","baseexternalclient_1","externalAccountAuthorizedUserClient_1","GoogleAuthExceptionMessages","NO_PROJECT_ID_FOUND","isGCE","checkIsGCE","constructor","opts","undefined","jsonContent","cachedCredential","_cachedProjectId","projectId","authClient","keyFilename","keyFile","scopes","credentials","clientOptions","setGapicJWTValues","client","defaultServicePath","useJWTAccessWithScope","defaultScopes","getProjectId","callback","getProjectIdAsync","then","r","getProjectIdOptional","_this","e","Error","message","findAndCacheProjectId","_this2","getProductionProjectId","getFileProjectId","getDefaultServiceProjectId","getGCEProjectId","getExternalAccountClientProjectId","_this3","_findProjectIdPromise","getAnyScopes","getApplicationDefault","optionsOrCallback","options","getApplicationDefaultAsync","credential","_this4","prepareAndCacheADC","quotaProjectIdOverride","process","env","_tryGetApplicationCredentialsFromEnvironmentVariable","JWT","BaseExternalAccountClient","_tryGetApplicationCredentialsFromWellKnownFile","_checkIsGCE","Compute","_this5","quotaProjectId","_this6","isAvailable","_this7","credentialsPath","length","_getApplicationCredentialsFromFilePath","_this8","location","_isWindows","home","join","existsSync","filePath","_this9","realpathSync","lstatSync","isFile","err","readStream","createReadStream","fromStream","fromImpersonatedJSON","json","_a","_b","_c","_d","type","IMPERSONATED_ACCOUNT_TYPE","source_credentials","service_account_impersonation_url","sourceClient","UserRefreshClient","client_id","client_secret","refresh_token","targetPrincipal","exec","groups","target","RangeError","targetScopes","Impersonated","delegates","Array","isArray","fromJSON","USER_REFRESH_ACCOUNT_TYPE","EXTERNAL_ACCOUNT_TYPE","ExternalAccountClient","EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE","ExternalAccountAuthorizedUserClient","_cacheClientFromJSON","inputStream","fromStreamAsync","Promise","resolve","reject","s","setEncoding","on","chunk","data","JSON","parse","fromAPIKey","apiKey","sys","platform","substring","toLowerCase","stdout","configuration","properties","core","project","_this10","creds","getClient","_this11","getCredentials","getCredentialsAsync","_this12","serviceAccountEmail","getServiceAccountEmail","client_email","private_key","instance","property","params","recursive","email","_this13","stream","getIdTokenClient","targetAudience","_this14","IdTokenClient","idTokenProvider","getAccessToken","_this15","token","getRequestHeaders","url","_this16","authorizeRequest","_this17","uri","headers","assign","request","_this18","getEnv","sign","_this19","crypto","createCrypto","key","signBlob","emailOrUniqueId","_this20","res","method","payload","encodeBase64StringUtf8","signedBlob","DefaultTransporter"],"sources":["D:/graduation project/Graduation_Project-Dubbizel--main/Graduation_Project-Dubbizel--main/Dubbizel_Angular/node_modules/google-auth-library/build/src/auth/googleauth.js"],"sourcesContent":["\"use strict\";\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GoogleAuth = exports.CLOUD_SDK_CLIENT_ID = void 0;\nconst child_process_1 = require(\"child_process\");\nconst fs = require(\"fs\");\nconst gcpMetadata = require(\"gcp-metadata\");\nconst os = require(\"os\");\nconst path = require(\"path\");\nconst crypto_1 = require(\"../crypto/crypto\");\nconst transporters_1 = require(\"../transporters\");\nconst computeclient_1 = require(\"./computeclient\");\nconst idtokenclient_1 = require(\"./idtokenclient\");\nconst envDetect_1 = require(\"./envDetect\");\nconst jwtclient_1 = require(\"./jwtclient\");\nconst refreshclient_1 = require(\"./refreshclient\");\nconst impersonated_1 = require(\"./impersonated\");\nconst externalclient_1 = require(\"./externalclient\");\nconst baseexternalclient_1 = require(\"./baseexternalclient\");\nconst externalAccountAuthorizedUserClient_1 = require(\"./externalAccountAuthorizedUserClient\");\nexports.CLOUD_SDK_CLIENT_ID = '764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com';\nconst GoogleAuthExceptionMessages = {\n    NO_PROJECT_ID_FOUND: 'Unable to detect a Project Id in the current environment. \\n' +\n        'To learn more about authentication and Google APIs, visit: \\n' +\n        'https://cloud.google.com/docs/authentication/getting-started',\n};\nclass GoogleAuth {\n    // Note:  this properly is only public to satisify unit tests.\n    // https://github.com/Microsoft/TypeScript/issues/5228\n    get isGCE() {\n        return this.checkIsGCE;\n    }\n    constructor(opts) {\n        /**\n         * Caches a value indicating whether the auth layer is running on Google\n         * Compute Engine.\n         * @private\n         */\n        this.checkIsGCE = undefined;\n        // To save the contents of the JSON credential file\n        this.jsonContent = null;\n        this.cachedCredential = null;\n        opts = opts || {};\n        this._cachedProjectId = opts.projectId || null;\n        this.cachedCredential = opts.authClient || null;\n        this.keyFilename = opts.keyFilename || opts.keyFile;\n        this.scopes = opts.scopes;\n        this.jsonContent = opts.credentials || null;\n        this.clientOptions = opts.clientOptions;\n    }\n    // GAPIC client libraries should always use self-signed JWTs. The following\n    // variables are set on the JWT client in order to indicate the type of library,\n    // and sign the JWT with the correct audience and scopes (if not supplied).\n    setGapicJWTValues(client) {\n        client.defaultServicePath = this.defaultServicePath;\n        client.useJWTAccessWithScope = this.useJWTAccessWithScope;\n        client.defaultScopes = this.defaultScopes;\n    }\n    getProjectId(callback) {\n        if (callback) {\n            this.getProjectIdAsync().then(r => callback(null, r), callback);\n        }\n        else {\n            return this.getProjectIdAsync();\n        }\n    }\n    /**\n     * A temporary method for internal `getProjectId` usages where `null` is\n     * acceptable. In a future major release, `getProjectId` should return `null`\n     * (as the `Promise<string | null>` base signature describes) and this private\n     * method should be removed.\n     *\n     * @returns Promise that resolves with project id (or `null`)\n     */\n    async getProjectIdOptional() {\n        try {\n            return await this.getProjectId();\n        }\n        catch (e) {\n            if (e instanceof Error &&\n                e.message === GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND) {\n                return null;\n            }\n            else {\n                throw e;\n            }\n        }\n    }\n    /*\n     * A private method for finding and caching a projectId.\n     *\n     * Supports environments in order of precedence:\n     * - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\n     * - GOOGLE_APPLICATION_CREDENTIALS JSON file\n     * - Cloud SDK: `gcloud config config-helper --format json`\n     * - GCE project ID from metadata server\n     *\n     * @returns projectId\n     */\n    async findAndCacheProjectId() {\n        let projectId = null;\n        projectId || (projectId = await this.getProductionProjectId());\n        projectId || (projectId = await this.getFileProjectId());\n        projectId || (projectId = await this.getDefaultServiceProjectId());\n        projectId || (projectId = await this.getGCEProjectId());\n        projectId || (projectId = await this.getExternalAccountClientProjectId());\n        if (projectId) {\n            this._cachedProjectId = projectId;\n            return projectId;\n        }\n        else {\n            throw new Error(GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND);\n        }\n    }\n    async getProjectIdAsync() {\n        if (this._cachedProjectId) {\n            return this._cachedProjectId;\n        }\n        if (!this._findProjectIdPromise) {\n            this._findProjectIdPromise = this.findAndCacheProjectId();\n        }\n        return this._findProjectIdPromise;\n    }\n    /**\n     * @returns Any scopes (user-specified or default scopes specified by the\n     *   client library) that need to be set on the current Auth client.\n     */\n    getAnyScopes() {\n        return this.scopes || this.defaultScopes;\n    }\n    getApplicationDefault(optionsOrCallback = {}, callback) {\n        let options;\n        if (typeof optionsOrCallback === 'function') {\n            callback = optionsOrCallback;\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        if (callback) {\n            this.getApplicationDefaultAsync(options).then(r => callback(null, r.credential, r.projectId), callback);\n        }\n        else {\n            return this.getApplicationDefaultAsync(options);\n        }\n    }\n    async getApplicationDefaultAsync(options = {}) {\n        // If we've already got a cached credential, return it.\n        // This will also preserve one's configured quota project, in case they\n        // set one directly on the credential previously.\n        if (this.cachedCredential) {\n            return await this.prepareAndCacheADC(this.cachedCredential);\n        }\n        // Since this is a 'new' ADC to cache we will use the environment variable\n        // if it's available. We prefer this value over the value from ADC.\n        const quotaProjectIdOverride = process.env['GOOGLE_CLOUD_QUOTA_PROJECT'];\n        let credential;\n        // Check for the existence of a local environment variable pointing to the\n        // location of the credential file. This is typically used in local\n        // developer scenarios.\n        credential =\n            await this._tryGetApplicationCredentialsFromEnvironmentVariable(options);\n        if (credential) {\n            if (credential instanceof jwtclient_1.JWT) {\n                credential.scopes = this.scopes;\n            }\n            else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\n                credential.scopes = this.getAnyScopes();\n            }\n            return await this.prepareAndCacheADC(credential, quotaProjectIdOverride);\n        }\n        // Look in the well-known credential file location.\n        credential = await this._tryGetApplicationCredentialsFromWellKnownFile(options);\n        if (credential) {\n            if (credential instanceof jwtclient_1.JWT) {\n                credential.scopes = this.scopes;\n            }\n            else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\n                credential.scopes = this.getAnyScopes();\n            }\n            return await this.prepareAndCacheADC(credential, quotaProjectIdOverride);\n        }\n        // Determine if we're running on GCE.\n        let isGCE;\n        try {\n            isGCE = await this._checkIsGCE();\n        }\n        catch (e) {\n            if (e instanceof Error) {\n                e.message = `Unexpected error determining execution environment: ${e.message}`;\n            }\n            throw e;\n        }\n        if (!isGCE) {\n            // We failed to find the default credentials. Bail out with an error.\n            throw new Error('Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.');\n        }\n        // For GCE, just return a default ComputeClient. It will take care of\n        // the rest.\n        options.scopes = this.getAnyScopes();\n        return await this.prepareAndCacheADC(new computeclient_1.Compute(options), quotaProjectIdOverride);\n    }\n    async prepareAndCacheADC(credential, quotaProjectIdOverride) {\n        const projectId = await this.getProjectIdOptional();\n        if (quotaProjectIdOverride) {\n            credential.quotaProjectId = quotaProjectIdOverride;\n        }\n        this.cachedCredential = credential;\n        return { credential, projectId };\n    }\n    /**\n     * Determines whether the auth layer is running on Google Compute Engine.\n     * @returns A promise that resolves with the boolean.\n     * @api private\n     */\n    async _checkIsGCE() {\n        if (this.checkIsGCE === undefined) {\n            this.checkIsGCE = await gcpMetadata.isAvailable();\n        }\n        return this.checkIsGCE;\n    }\n    /**\n     * Attempts to load default credentials from the environment variable path..\n     * @returns Promise that resolves with the OAuth2Client or null.\n     * @api private\n     */\n    async _tryGetApplicationCredentialsFromEnvironmentVariable(options) {\n        const credentialsPath = process.env['GOOGLE_APPLICATION_CREDENTIALS'] ||\n            process.env['google_application_credentials'];\n        if (!credentialsPath || credentialsPath.length === 0) {\n            return null;\n        }\n        try {\n            return this._getApplicationCredentialsFromFilePath(credentialsPath, options);\n        }\n        catch (e) {\n            if (e instanceof Error) {\n                e.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ${e.message}`;\n            }\n            throw e;\n        }\n    }\n    /**\n     * Attempts to load default credentials from a well-known file location\n     * @return Promise that resolves with the OAuth2Client or null.\n     * @api private\n     */\n    async _tryGetApplicationCredentialsFromWellKnownFile(options) {\n        // First, figure out the location of the file, depending upon the OS type.\n        let location = null;\n        if (this._isWindows()) {\n            // Windows\n            location = process.env['APPDATA'];\n        }\n        else {\n            // Linux or Mac\n            const home = process.env['HOME'];\n            if (home) {\n                location = path.join(home, '.config');\n            }\n        }\n        // If we found the root path, expand it.\n        if (location) {\n            location = path.join(location, 'gcloud', 'application_default_credentials.json');\n            if (!fs.existsSync(location)) {\n                location = null;\n            }\n        }\n        // The file does not exist.\n        if (!location) {\n            return null;\n        }\n        // The file seems to exist. Try to use it.\n        const client = await this._getApplicationCredentialsFromFilePath(location, options);\n        return client;\n    }\n    /**\n     * Attempts to load default credentials from a file at the given path..\n     * @param filePath The path to the file to read.\n     * @returns Promise that resolves with the OAuth2Client\n     * @api private\n     */\n    async _getApplicationCredentialsFromFilePath(filePath, options = {}) {\n        // Make sure the path looks like a string.\n        if (!filePath || filePath.length === 0) {\n            throw new Error('The file path is invalid.');\n        }\n        // Make sure there is a file at the path. lstatSync will throw if there is\n        // nothing there.\n        try {\n            // Resolve path to actual file in case of symlink. Expect a thrown error\n            // if not resolvable.\n            filePath = fs.realpathSync(filePath);\n            if (!fs.lstatSync(filePath).isFile()) {\n                throw new Error();\n            }\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\n            }\n            throw err;\n        }\n        // Now open a read stream on the file, and parse it.\n        const readStream = fs.createReadStream(filePath);\n        return this.fromStream(readStream, options);\n    }\n    /**\n     * Create a credentials instance using a given impersonated input options.\n     * @param json The impersonated input object.\n     * @returns JWT or UserRefresh Client with data\n     */\n    fromImpersonatedJSON(json) {\n        var _a, _b, _c, _d;\n        if (!json) {\n            throw new Error('Must pass in a JSON object containing an  impersonated refresh token');\n        }\n        if (json.type !== impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {\n            throw new Error(`The incoming JSON object does not have the \"${impersonated_1.IMPERSONATED_ACCOUNT_TYPE}\" type`);\n        }\n        if (!json.source_credentials) {\n            throw new Error('The incoming JSON object does not contain a source_credentials field');\n        }\n        if (!json.service_account_impersonation_url) {\n            throw new Error('The incoming JSON object does not contain a service_account_impersonation_url field');\n        }\n        // Create source client for impersonation\n        const sourceClient = new refreshclient_1.UserRefreshClient(json.source_credentials.client_id, json.source_credentials.client_secret, json.source_credentials.refresh_token);\n        // Extreact service account from service_account_impersonation_url\n        const targetPrincipal = (_b = (_a = /(?<target>[^/]+):generateAccessToken$/.exec(json.service_account_impersonation_url)) === null || _a === void 0 ? void 0 : _a.groups) === null || _b === void 0 ? void 0 : _b.target;\n        if (!targetPrincipal) {\n            throw new RangeError(`Cannot extract target principal from ${json.service_account_impersonation_url}`);\n        }\n        const targetScopes = (_c = this.getAnyScopes()) !== null && _c !== void 0 ? _c : [];\n        const client = new impersonated_1.Impersonated({\n            delegates: (_d = json.delegates) !== null && _d !== void 0 ? _d : [],\n            sourceClient: sourceClient,\n            targetPrincipal: targetPrincipal,\n            targetScopes: Array.isArray(targetScopes) ? targetScopes : [targetScopes],\n        });\n        return client;\n    }\n    /**\n     * Create a credentials instance using the given input options.\n     * @param json The input object.\n     * @param options The JWT or UserRefresh options for the client\n     * @returns JWT or UserRefresh Client with data\n     */\n    fromJSON(json, options = {}) {\n        let client;\n        options = options || {};\n        if (json.type === refreshclient_1.USER_REFRESH_ACCOUNT_TYPE) {\n            client = new refreshclient_1.UserRefreshClient(options);\n            client.fromJSON(json);\n        }\n        else if (json.type === impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {\n            client = this.fromImpersonatedJSON(json);\n        }\n        else if (json.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n            client = externalclient_1.ExternalAccountClient.fromJSON(json, options);\n            client.scopes = this.getAnyScopes();\n        }\n        else if (json.type === externalAccountAuthorizedUserClient_1.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE) {\n            client = new externalAccountAuthorizedUserClient_1.ExternalAccountAuthorizedUserClient(json, options);\n        }\n        else {\n            options.scopes = this.scopes;\n            client = new jwtclient_1.JWT(options);\n            this.setGapicJWTValues(client);\n            client.fromJSON(json);\n        }\n        return client;\n    }\n    /**\n     * Return a JWT or UserRefreshClient from JavaScript object, caching both the\n     * object used to instantiate and the client.\n     * @param json The input object.\n     * @param options The JWT or UserRefresh options for the client\n     * @returns JWT or UserRefresh Client with data\n     */\n    _cacheClientFromJSON(json, options) {\n        const client = this.fromJSON(json, options);\n        // cache both raw data used to instantiate client and client itself.\n        this.jsonContent = json;\n        this.cachedCredential = client;\n        return client;\n    }\n    fromStream(inputStream, optionsOrCallback = {}, callback) {\n        let options = {};\n        if (typeof optionsOrCallback === 'function') {\n            callback = optionsOrCallback;\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        if (callback) {\n            this.fromStreamAsync(inputStream, options).then(r => callback(null, r), callback);\n        }\n        else {\n            return this.fromStreamAsync(inputStream, options);\n        }\n    }\n    fromStreamAsync(inputStream, options) {\n        return new Promise((resolve, reject) => {\n            if (!inputStream) {\n                throw new Error('Must pass in a stream containing the Google auth settings.');\n            }\n            let s = '';\n            inputStream\n                .setEncoding('utf8')\n                .on('error', reject)\n                .on('data', chunk => (s += chunk))\n                .on('end', () => {\n                try {\n                    try {\n                        const data = JSON.parse(s);\n                        const r = this._cacheClientFromJSON(data, options);\n                        return resolve(r);\n                    }\n                    catch (err) {\n                        // If we failed parsing this.keyFileName, assume that it\n                        // is a PEM or p12 certificate:\n                        if (!this.keyFilename)\n                            throw err;\n                        const client = new jwtclient_1.JWT({\n                            ...this.clientOptions,\n                            keyFile: this.keyFilename,\n                        });\n                        this.cachedCredential = client;\n                        this.setGapicJWTValues(client);\n                        return resolve(client);\n                    }\n                }\n                catch (err) {\n                    return reject(err);\n                }\n            });\n        });\n    }\n    /**\n     * Create a credentials instance using the given API key string.\n     * @param apiKey The API key string\n     * @param options An optional options object.\n     * @returns A JWT loaded from the key\n     */\n    fromAPIKey(apiKey, options) {\n        options = options || {};\n        const client = new jwtclient_1.JWT(options);\n        client.fromAPIKey(apiKey);\n        return client;\n    }\n    /**\n     * Determines whether the current operating system is Windows.\n     * @api private\n     */\n    _isWindows() {\n        const sys = os.platform();\n        if (sys && sys.length >= 3) {\n            if (sys.substring(0, 3).toLowerCase() === 'win') {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Run the Google Cloud SDK command that prints the default project ID\n     */\n    async getDefaultServiceProjectId() {\n        return new Promise(resolve => {\n            (0, child_process_1.exec)('gcloud config config-helper --format json', (err, stdout) => {\n                if (!err && stdout) {\n                    try {\n                        const projectId = JSON.parse(stdout).configuration.properties.core.project;\n                        resolve(projectId);\n                        return;\n                    }\n                    catch (e) {\n                        // ignore errors\n                    }\n                }\n                resolve(null);\n            });\n        });\n    }\n    /**\n     * Loads the project id from environment variables.\n     * @api private\n     */\n    getProductionProjectId() {\n        return (process.env['GCLOUD_PROJECT'] ||\n            process.env['GOOGLE_CLOUD_PROJECT'] ||\n            process.env['gcloud_project'] ||\n            process.env['google_cloud_project']);\n    }\n    /**\n     * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\n     * @api private\n     */\n    async getFileProjectId() {\n        if (this.cachedCredential) {\n            // Try to read the project ID from the cached credentials file\n            return this.cachedCredential.projectId;\n        }\n        // Ensure the projectId is loaded from the keyFile if available.\n        if (this.keyFilename) {\n            const creds = await this.getClient();\n            if (creds && creds.projectId) {\n                return creds.projectId;\n            }\n        }\n        // Try to load a credentials file and read its project ID\n        const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();\n        if (r) {\n            return r.projectId;\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Gets the project ID from external account client if available.\n     */\n    async getExternalAccountClientProjectId() {\n        if (!this.jsonContent || this.jsonContent.type !== baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n            return null;\n        }\n        const creds = await this.getClient();\n        // Do not suppress the underlying error, as the error could contain helpful\n        // information for debugging and fixing. This is especially true for\n        // external account creds as in order to get the project ID, the following\n        // operations have to succeed:\n        // 1. Valid credentials file should be supplied.\n        // 2. Ability to retrieve access tokens from STS token exchange API.\n        // 3. Ability to exchange for service account impersonated credentials (if\n        //    enabled).\n        // 4. Ability to get project info using the access token from step 2 or 3.\n        // Without surfacing the error, it is harder for developers to determine\n        // which step went wrong.\n        return await creds.getProjectId();\n    }\n    /**\n     * Gets the Compute Engine project ID if it can be inferred.\n     */\n    async getGCEProjectId() {\n        try {\n            const r = await gcpMetadata.project('project-id');\n            return r;\n        }\n        catch (e) {\n            // Ignore any errors\n            return null;\n        }\n    }\n    getCredentials(callback) {\n        if (callback) {\n            this.getCredentialsAsync().then(r => callback(null, r), callback);\n        }\n        else {\n            return this.getCredentialsAsync();\n        }\n    }\n    async getCredentialsAsync() {\n        const client = await this.getClient();\n        if (client instanceof baseexternalclient_1.BaseExternalAccountClient) {\n            const serviceAccountEmail = client.getServiceAccountEmail();\n            if (serviceAccountEmail) {\n                return { client_email: serviceAccountEmail };\n            }\n        }\n        if (this.jsonContent) {\n            const credential = {\n                client_email: this.jsonContent.client_email,\n                private_key: this.jsonContent.private_key,\n            };\n            return credential;\n        }\n        const isGCE = await this._checkIsGCE();\n        if (!isGCE) {\n            throw new Error('Unknown error.');\n        }\n        // For GCE, return the service account details from the metadata server\n        // NOTE: The trailing '/' at the end of service-accounts/ is very important!\n        // The GCF metadata server doesn't respect querystring params if this / is\n        // not included.\n        const data = await gcpMetadata.instance({\n            property: 'service-accounts/',\n            params: { recursive: 'true' },\n        });\n        if (!data || !data.default || !data.default.email) {\n            throw new Error('Failure from metadata server.');\n        }\n        return { client_email: data.default.email };\n    }\n    /**\n     * Automatically obtain a client based on the provided configuration.  If no\n     * options were passed, use Application Default Credentials.\n     */\n    async getClient() {\n        if (!this.cachedCredential) {\n            if (this.jsonContent) {\n                this._cacheClientFromJSON(this.jsonContent, this.clientOptions);\n            }\n            else if (this.keyFilename) {\n                const filePath = path.resolve(this.keyFilename);\n                const stream = fs.createReadStream(filePath);\n                await this.fromStreamAsync(stream, this.clientOptions);\n            }\n            else {\n                await this.getApplicationDefaultAsync(this.clientOptions);\n            }\n        }\n        return this.cachedCredential;\n    }\n    /**\n     * Creates a client which will fetch an ID token for authorization.\n     * @param targetAudience the audience for the fetched ID token.\n     * @returns IdTokenClient for making HTTP calls authenticated with ID tokens.\n     */\n    async getIdTokenClient(targetAudience) {\n        const client = await this.getClient();\n        if (!('fetchIdToken' in client)) {\n            throw new Error('Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.');\n        }\n        return new idtokenclient_1.IdTokenClient({ targetAudience, idTokenProvider: client });\n    }\n    /**\n     * Automatically obtain application default credentials, and return\n     * an access token for making requests.\n     */\n    async getAccessToken() {\n        const client = await this.getClient();\n        return (await client.getAccessToken()).token;\n    }\n    /**\n     * Obtain the HTTP headers that will provide authorization for a given\n     * request.\n     */\n    async getRequestHeaders(url) {\n        const client = await this.getClient();\n        return client.getRequestHeaders(url);\n    }\n    /**\n     * Obtain credentials for a request, then attach the appropriate headers to\n     * the request options.\n     * @param opts Axios or Request options on which to attach the headers\n     */\n    async authorizeRequest(opts) {\n        opts = opts || {};\n        const url = opts.url || opts.uri;\n        const client = await this.getClient();\n        const headers = await client.getRequestHeaders(url);\n        opts.headers = Object.assign(opts.headers || {}, headers);\n        return opts;\n    }\n    /**\n     * Automatically obtain application default credentials, and make an\n     * HTTP request using the given options.\n     * @param opts Axios request options for the HTTP request.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async request(opts) {\n        const client = await this.getClient();\n        return client.request(opts);\n    }\n    /**\n     * Determine the compute environment in which the code is running.\n     */\n    getEnv() {\n        return (0, envDetect_1.getEnv)();\n    }\n    /**\n     * Sign the given data with the current private key, or go out\n     * to the IAM API to sign it.\n     * @param data The data to be signed.\n     */\n    async sign(data) {\n        const client = await this.getClient();\n        const crypto = (0, crypto_1.createCrypto)();\n        if (client instanceof jwtclient_1.JWT && client.key) {\n            const sign = await crypto.sign(client.key, data);\n            return sign;\n        }\n        const creds = await this.getCredentials();\n        if (!creds.client_email) {\n            throw new Error('Cannot sign data without `client_email`.');\n        }\n        return this.signBlob(crypto, creds.client_email, data);\n    }\n    async signBlob(crypto, emailOrUniqueId, data) {\n        const url = 'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/' +\n            `${emailOrUniqueId}:signBlob`;\n        const res = await this.request({\n            method: 'POST',\n            url,\n            data: {\n                payload: crypto.encodeBase64StringUtf8(data),\n            },\n        });\n        return res.data.signedBlob;\n    }\n}\nexports.GoogleAuth = GoogleAuth;\n/**\n * Export DefaultTransporter as a static property of the class.\n */\nGoogleAuth.DefaultTransporter = transporters_1.DefaultTransporter;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}