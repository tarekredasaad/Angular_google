{"ast":null,"code":"\"use strict\";\n\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar _asyncToGenerator = require(\"D:/graduation project/Graduation_Project-Dubbizel--main/Graduation_Project-Dubbizel--main/Dubbizel_Angular/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _a, _b, _c;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IdentityPoolClient = void 0;\nconst fs = require(\"fs\");\nconst util_1 = require(\"util\");\nconst baseexternalclient_1 = require(\"./baseexternalclient\");\n// fs.readfile is undefined in browser karma tests causing\n// `npm run browser-test` to fail as test.oauth2.ts imports this file via\n// src/index.ts.\n// Fallback to void function to avoid promisify throwing a TypeError.\nconst readFile = (0, util_1.promisify)((_a = fs.readFile) !== null && _a !== void 0 ? _a : () => {});\nconst realpath = (0, util_1.promisify)((_b = fs.realpath) !== null && _b !== void 0 ? _b : () => {});\nconst lstat = (0, util_1.promisify)((_c = fs.lstat) !== null && _c !== void 0 ? _c : () => {});\n/**\n * Defines the Url-sourced and file-sourced external account clients mainly\n * used for K8s and Azure workloads.\n */\nclass IdentityPoolClient extends baseexternalclient_1.BaseExternalAccountClient {\n  /**\n   * Instantiate an IdentityPoolClient instance using the provided JSON\n   * object loaded from an external account credentials file.\n   * An error is thrown if the credential is not a valid file-sourced or\n   * url-sourced credential or a workforce pool user project is provided\n   * with a non workforce audience.\n   * @param options The external account options object typically loaded\n   *   from the external account JSON credential file.\n   * @param additionalOptions Optional additional behavior customization\n   *   options. These currently customize expiration threshold time and\n   *   whether to retry on 401/403 API request errors.\n   */\n  constructor(options, additionalOptions) {\n    var _a, _b;\n    super(options, additionalOptions);\n    this.file = options.credential_source.file;\n    this.url = options.credential_source.url;\n    this.headers = options.credential_source.headers;\n    if (!this.file && !this.url) {\n      throw new Error('No valid Identity Pool \"credential_source\" provided');\n    }\n    // Text is the default format type.\n    this.formatType = ((_a = options.credential_source.format) === null || _a === void 0 ? void 0 : _a.type) || 'text';\n    this.formatSubjectTokenFieldName = (_b = options.credential_source.format) === null || _b === void 0 ? void 0 : _b.subject_token_field_name;\n    if (this.formatType !== 'json' && this.formatType !== 'text') {\n      throw new Error(`Invalid credential_source format \"${this.formatType}\"`);\n    }\n    if (this.formatType === 'json' && !this.formatSubjectTokenFieldName) {\n      throw new Error('Missing subject_token_field_name for JSON credential_source format');\n    }\n  }\n  /**\n   * Triggered when a external subject token is needed to be exchanged for a GCP\n   * access token via GCP STS endpoint.\n   * This uses the `options.credential_source` object to figure out how\n   * to retrieve the token using the current environment. In this case,\n   * this either retrieves the local credential from a file location (k8s\n   * workload) or by sending a GET request to a local metadata server (Azure\n   * workloads).\n   * @return A promise that resolves with the external subject token.\n   */\n  retrieveSubjectToken() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (_this.file) {\n        return yield _this.getTokenFromFile(_this.file, _this.formatType, _this.formatSubjectTokenFieldName);\n      }\n      return yield _this.getTokenFromUrl(_this.url, _this.formatType, _this.formatSubjectTokenFieldName, _this.headers);\n    })();\n  }\n  /**\n   * Looks up the external subject token in the file path provided and\n   * resolves with that token.\n   * @param file The file path where the external credential is located.\n   * @param formatType The token file or URL response type (JSON or text).\n   * @param formatSubjectTokenFieldName For JSON response types, this is the\n   *   subject_token field name. For Azure, this is access_token. For text\n   *   response types, this is ignored.\n   * @return A promise that resolves with the external subject token.\n   */\n  getTokenFromFile(filePath, formatType, formatSubjectTokenFieldName) {\n    return _asyncToGenerator(function* () {\n      // Make sure there is a file at the path. lstatSync will throw if there is\n      // nothing there.\n      try {\n        // Resolve path to actual file in case of symlink. Expect a thrown error\n        // if not resolvable.\n        filePath = yield realpath(filePath);\n        if (!(yield lstat(filePath)).isFile()) {\n          throw new Error();\n        }\n      } catch (err) {\n        if (err instanceof Error) {\n          err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\n        }\n        throw err;\n      }\n      let subjectToken;\n      const rawText = yield readFile(filePath, {\n        encoding: 'utf8'\n      });\n      if (formatType === 'text') {\n        subjectToken = rawText;\n      } else if (formatType === 'json' && formatSubjectTokenFieldName) {\n        const json = JSON.parse(rawText);\n        subjectToken = json[formatSubjectTokenFieldName];\n      }\n      if (!subjectToken) {\n        throw new Error('Unable to parse the subject_token from the credential_source file');\n      }\n      return subjectToken;\n    })();\n  }\n  /**\n   * Sends a GET request to the URL provided and resolves with the returned\n   * external subject token.\n   * @param url The URL to call to retrieve the subject token. This is typically\n   *   a local metadata server.\n   * @param formatType The token file or URL response type (JSON or text).\n   * @param formatSubjectTokenFieldName For JSON response types, this is the\n   *   subject_token field name. For Azure, this is access_token. For text\n   *   response types, this is ignored.\n   * @param headers The optional additional headers to send with the request to\n   *   the metadata server url.\n   * @return A promise that resolves with the external subject token.\n   */\n  getTokenFromUrl(url, formatType, formatSubjectTokenFieldName, headers) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const opts = {\n        url,\n        method: 'GET',\n        headers,\n        responseType: formatType\n      };\n      let subjectToken;\n      if (formatType === 'text') {\n        const response = yield _this2.transporter.request(opts);\n        subjectToken = response.data;\n      } else if (formatType === 'json' && formatSubjectTokenFieldName) {\n        const response = yield _this2.transporter.request(opts);\n        subjectToken = response.data[formatSubjectTokenFieldName];\n      }\n      if (!subjectToken) {\n        throw new Error('Unable to parse the subject_token from the credential_source URL');\n      }\n      return subjectToken;\n    })();\n  }\n}\nexports.IdentityPoolClient = IdentityPoolClient;","map":{"version":3,"names":["_asyncToGenerator","require","default","_a","_b","_c","Object","defineProperty","exports","value","IdentityPoolClient","fs","util_1","baseexternalclient_1","readFile","promisify","realpath","lstat","BaseExternalAccountClient","constructor","options","additionalOptions","file","credential_source","url","headers","Error","formatType","format","type","formatSubjectTokenFieldName","subject_token_field_name","retrieveSubjectToken","_this","getTokenFromFile","getTokenFromUrl","filePath","isFile","err","message","subjectToken","rawText","encoding","json","JSON","parse","_this2","opts","method","responseType","response","transporter","request","data"],"sources":["D:/graduation project/Graduation_Project-Dubbizel--main/Graduation_Project-Dubbizel--main/Dubbizel_Angular/node_modules/google-auth-library/build/src/auth/identitypoolclient.js"],"sourcesContent":["\"use strict\";\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar _a, _b, _c;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IdentityPoolClient = void 0;\nconst fs = require(\"fs\");\nconst util_1 = require(\"util\");\nconst baseexternalclient_1 = require(\"./baseexternalclient\");\n// fs.readfile is undefined in browser karma tests causing\n// `npm run browser-test` to fail as test.oauth2.ts imports this file via\n// src/index.ts.\n// Fallback to void function to avoid promisify throwing a TypeError.\nconst readFile = (0, util_1.promisify)((_a = fs.readFile) !== null && _a !== void 0 ? _a : (() => { }));\nconst realpath = (0, util_1.promisify)((_b = fs.realpath) !== null && _b !== void 0 ? _b : (() => { }));\nconst lstat = (0, util_1.promisify)((_c = fs.lstat) !== null && _c !== void 0 ? _c : (() => { }));\n/**\n * Defines the Url-sourced and file-sourced external account clients mainly\n * used for K8s and Azure workloads.\n */\nclass IdentityPoolClient extends baseexternalclient_1.BaseExternalAccountClient {\n    /**\n     * Instantiate an IdentityPoolClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * An error is thrown if the credential is not a valid file-sourced or\n     * url-sourced credential or a workforce pool user project is provided\n     * with a non workforce audience.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     */\n    constructor(options, additionalOptions) {\n        var _a, _b;\n        super(options, additionalOptions);\n        this.file = options.credential_source.file;\n        this.url = options.credential_source.url;\n        this.headers = options.credential_source.headers;\n        if (!this.file && !this.url) {\n            throw new Error('No valid Identity Pool \"credential_source\" provided');\n        }\n        // Text is the default format type.\n        this.formatType = ((_a = options.credential_source.format) === null || _a === void 0 ? void 0 : _a.type) || 'text';\n        this.formatSubjectTokenFieldName =\n            (_b = options.credential_source.format) === null || _b === void 0 ? void 0 : _b.subject_token_field_name;\n        if (this.formatType !== 'json' && this.formatType !== 'text') {\n            throw new Error(`Invalid credential_source format \"${this.formatType}\"`);\n        }\n        if (this.formatType === 'json' && !this.formatSubjectTokenFieldName) {\n            throw new Error('Missing subject_token_field_name for JSON credential_source format');\n        }\n    }\n    /**\n     * Triggered when a external subject token is needed to be exchanged for a GCP\n     * access token via GCP STS endpoint.\n     * This uses the `options.credential_source` object to figure out how\n     * to retrieve the token using the current environment. In this case,\n     * this either retrieves the local credential from a file location (k8s\n     * workload) or by sending a GET request to a local metadata server (Azure\n     * workloads).\n     * @return A promise that resolves with the external subject token.\n     */\n    async retrieveSubjectToken() {\n        if (this.file) {\n            return await this.getTokenFromFile(this.file, this.formatType, this.formatSubjectTokenFieldName);\n        }\n        return await this.getTokenFromUrl(this.url, this.formatType, this.formatSubjectTokenFieldName, this.headers);\n    }\n    /**\n     * Looks up the external subject token in the file path provided and\n     * resolves with that token.\n     * @param file The file path where the external credential is located.\n     * @param formatType The token file or URL response type (JSON or text).\n     * @param formatSubjectTokenFieldName For JSON response types, this is the\n     *   subject_token field name. For Azure, this is access_token. For text\n     *   response types, this is ignored.\n     * @return A promise that resolves with the external subject token.\n     */\n    async getTokenFromFile(filePath, formatType, formatSubjectTokenFieldName) {\n        // Make sure there is a file at the path. lstatSync will throw if there is\n        // nothing there.\n        try {\n            // Resolve path to actual file in case of symlink. Expect a thrown error\n            // if not resolvable.\n            filePath = await realpath(filePath);\n            if (!(await lstat(filePath)).isFile()) {\n                throw new Error();\n            }\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\n            }\n            throw err;\n        }\n        let subjectToken;\n        const rawText = await readFile(filePath, { encoding: 'utf8' });\n        if (formatType === 'text') {\n            subjectToken = rawText;\n        }\n        else if (formatType === 'json' && formatSubjectTokenFieldName) {\n            const json = JSON.parse(rawText);\n            subjectToken = json[formatSubjectTokenFieldName];\n        }\n        if (!subjectToken) {\n            throw new Error('Unable to parse the subject_token from the credential_source file');\n        }\n        return subjectToken;\n    }\n    /**\n     * Sends a GET request to the URL provided and resolves with the returned\n     * external subject token.\n     * @param url The URL to call to retrieve the subject token. This is typically\n     *   a local metadata server.\n     * @param formatType The token file or URL response type (JSON or text).\n     * @param formatSubjectTokenFieldName For JSON response types, this is the\n     *   subject_token field name. For Azure, this is access_token. For text\n     *   response types, this is ignored.\n     * @param headers The optional additional headers to send with the request to\n     *   the metadata server url.\n     * @return A promise that resolves with the external subject token.\n     */\n    async getTokenFromUrl(url, formatType, formatSubjectTokenFieldName, headers) {\n        const opts = {\n            url,\n            method: 'GET',\n            headers,\n            responseType: formatType,\n        };\n        let subjectToken;\n        if (formatType === 'text') {\n            const response = await this.transporter.request(opts);\n            subjectToken = response.data;\n        }\n        else if (formatType === 'json' && formatSubjectTokenFieldName) {\n            const response = await this.transporter.request(opts);\n            subjectToken = response.data[formatSubjectTokenFieldName];\n        }\n        if (!subjectToken) {\n            throw new Error('Unable to parse the subject_token from the credential_source URL');\n        }\n        return subjectToken;\n    }\n}\nexports.IdentityPoolClient = IdentityPoolClient;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}