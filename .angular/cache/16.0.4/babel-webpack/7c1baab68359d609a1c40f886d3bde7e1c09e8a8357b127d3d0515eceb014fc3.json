{"ast":null,"code":"\"use strict\";\n\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar _asyncToGenerator = require(\"D:/graduation project/Graduation_Project-Dubbizel--main/Graduation_Project-Dubbizel--main/Dubbizel_Angular/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OAuth2Client = exports.CertificateFormat = exports.CodeChallengeMethod = void 0;\nconst gaxios_1 = require(\"gaxios\");\nconst querystring = require(\"querystring\");\nconst stream = require(\"stream\");\nconst formatEcdsa = require(\"ecdsa-sig-formatter\");\nconst crypto_1 = require(\"../crypto/crypto\");\nconst authclient_1 = require(\"./authclient\");\nconst loginticket_1 = require(\"./loginticket\");\nvar CodeChallengeMethod;\n(function (CodeChallengeMethod) {\n  CodeChallengeMethod[\"Plain\"] = \"plain\";\n  CodeChallengeMethod[\"S256\"] = \"S256\";\n})(CodeChallengeMethod = exports.CodeChallengeMethod || (exports.CodeChallengeMethod = {}));\nvar CertificateFormat;\n(function (CertificateFormat) {\n  CertificateFormat[\"PEM\"] = \"PEM\";\n  CertificateFormat[\"JWK\"] = \"JWK\";\n})(CertificateFormat = exports.CertificateFormat || (exports.CertificateFormat = {}));\nclass OAuth2Client extends authclient_1.AuthClient {\n  constructor(optionsOrClientId, clientSecret, redirectUri) {\n    super();\n    this.certificateCache = {};\n    this.certificateExpiry = null;\n    this.certificateCacheFormat = CertificateFormat.PEM;\n    this.refreshTokenPromises = new Map();\n    const opts = optionsOrClientId && typeof optionsOrClientId === 'object' ? optionsOrClientId : {\n      clientId: optionsOrClientId,\n      clientSecret,\n      redirectUri\n    };\n    this._clientId = opts.clientId;\n    this._clientSecret = opts.clientSecret;\n    this.redirectUri = opts.redirectUri;\n    this.eagerRefreshThresholdMillis = opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n    this.forceRefreshOnFailure = !!opts.forceRefreshOnFailure;\n  }\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n  generateAuthUrl(opts = {}) {\n    if (opts.code_challenge_method && !opts.code_challenge) {\n      throw new Error('If a code_challenge_method is provided, code_challenge must be included.');\n    }\n    opts.response_type = opts.response_type || 'code';\n    opts.client_id = opts.client_id || this._clientId;\n    opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n    // Allow scopes to be passed either as array or a string\n    if (Array.isArray(opts.scope)) {\n      opts.scope = opts.scope.join(' ');\n    }\n    const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n    return rootUrl + '?' + querystring.stringify(opts);\n  }\n  generateCodeVerifier() {\n    // To make the code compatible with browser SubtleCrypto we need to make\n    // this method async.\n    throw new Error('generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.');\n  }\n  /**\n   * Convenience method to automatically generate a code_verifier, and its\n   * resulting SHA256. If used, this must be paired with a S256\n   * code_challenge_method.\n   *\n   * For a full example see:\n   * https://github.com/googleapis/google-auth-library-nodejs/blob/main/samples/oauth2-codeVerifier.js\n   */\n  generateCodeVerifierAsync() {\n    return _asyncToGenerator(function* () {\n      // base64 encoding uses 6 bits per character, and we want to generate128\n      // characters. 6*128/8 = 96.\n      const crypto = (0, crypto_1.createCrypto)();\n      const randomString = crypto.randomBytesBase64(96);\n      // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n      // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n      // swapping out a few chars.\n      const codeVerifier = randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-');\n      // Generate the base64 encoded SHA256\n      const unencodedCodeChallenge = yield crypto.sha256DigestBase64(codeVerifier);\n      // We need to use base64UrlEncoding instead of standard base64\n      const codeChallenge = unencodedCodeChallenge.split('=')[0].replace(/\\+/g, '-').replace(/\\//g, '_');\n      return {\n        codeVerifier,\n        codeChallenge\n      };\n    })();\n  }\n  getToken(codeOrOptions, callback) {\n    const options = typeof codeOrOptions === 'string' ? {\n      code: codeOrOptions\n    } : codeOrOptions;\n    if (callback) {\n      this.getTokenAsync(options).then(r => callback(null, r.tokens, r.res), e => callback(e, null, e.response));\n    } else {\n      return this.getTokenAsync(options);\n    }\n  }\n  getTokenAsync(options) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n      const values = {\n        code: options.code,\n        client_id: options.client_id || _this._clientId,\n        client_secret: _this._clientSecret,\n        redirect_uri: options.redirect_uri || _this.redirectUri,\n        grant_type: 'authorization_code',\n        code_verifier: options.codeVerifier\n      };\n      const res = yield _this.transporter.request({\n        method: 'POST',\n        url,\n        data: querystring.stringify(values),\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded'\n        }\n      });\n      const tokens = res.data;\n      if (res.data && res.data.expires_in) {\n        tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n        delete tokens.expires_in;\n      }\n      _this.emit('tokens', tokens);\n      return {\n        tokens,\n        res\n      };\n    })();\n  }\n  /**\n   * Refreshes the access token.\n   * @param refresh_token Existing refresh token.\n   * @private\n   */\n  refreshToken(refreshToken) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!refreshToken) {\n        return _this2.refreshTokenNoCache(refreshToken);\n      }\n      // If a request to refresh using the same token has started,\n      // return the same promise.\n      if (_this2.refreshTokenPromises.has(refreshToken)) {\n        return _this2.refreshTokenPromises.get(refreshToken);\n      }\n      const p = _this2.refreshTokenNoCache(refreshToken).then(r => {\n        _this2.refreshTokenPromises.delete(refreshToken);\n        return r;\n      }, e => {\n        _this2.refreshTokenPromises.delete(refreshToken);\n        throw e;\n      });\n      _this2.refreshTokenPromises.set(refreshToken, p);\n      return p;\n    })();\n  }\n  refreshTokenNoCache(refreshToken) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      if (!refreshToken) {\n        throw new Error('No refresh token is set.');\n      }\n      const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n      const data = {\n        refresh_token: refreshToken,\n        client_id: _this3._clientId,\n        client_secret: _this3._clientSecret,\n        grant_type: 'refresh_token'\n      };\n      let res;\n      try {\n        // request for new token\n        res = yield _this3.transporter.request({\n          method: 'POST',\n          url,\n          data: querystring.stringify(data),\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n          }\n        });\n      } catch (e) {\n        if (e instanceof gaxios_1.GaxiosError && e.message === 'invalid_grant' && ((_a = e.response) === null || _a === void 0 ? void 0 : _a.data) && /ReAuth/i.test(e.response.data.error_description)) {\n          e.message = JSON.stringify(e.response.data);\n        }\n        throw e;\n      }\n      const tokens = res.data;\n      // TODO: de-duplicate this code from a few spots\n      if (res.data && res.data.expires_in) {\n        tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n        delete tokens.expires_in;\n      }\n      _this3.emit('tokens', tokens);\n      return {\n        tokens,\n        res\n      };\n    })();\n  }\n  refreshAccessToken(callback) {\n    if (callback) {\n      this.refreshAccessTokenAsync().then(r => callback(null, r.credentials, r.res), callback);\n    } else {\n      return this.refreshAccessTokenAsync();\n    }\n  }\n  refreshAccessTokenAsync() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const r = yield _this4.refreshToken(_this4.credentials.refresh_token);\n      const tokens = r.tokens;\n      tokens.refresh_token = _this4.credentials.refresh_token;\n      _this4.credentials = tokens;\n      return {\n        credentials: _this4.credentials,\n        res: r.res\n      };\n    })();\n  }\n  getAccessToken(callback) {\n    if (callback) {\n      this.getAccessTokenAsync().then(r => callback(null, r.token, r.res), callback);\n    } else {\n      return this.getAccessTokenAsync();\n    }\n  }\n  getAccessTokenAsync() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const shouldRefresh = !_this5.credentials.access_token || _this5.isTokenExpiring();\n      if (shouldRefresh) {\n        if (!_this5.credentials.refresh_token) {\n          if (_this5.refreshHandler) {\n            const refreshedAccessToken = yield _this5.processAndValidateRefreshHandler();\n            if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\n              _this5.setCredentials(refreshedAccessToken);\n              return {\n                token: _this5.credentials.access_token\n              };\n            }\n          } else {\n            throw new Error('No refresh token or refresh handler callback is set.');\n          }\n        }\n        const r = yield _this5.refreshAccessTokenAsync();\n        if (!r.credentials || r.credentials && !r.credentials.access_token) {\n          throw new Error('Could not refresh access token.');\n        }\n        return {\n          token: r.credentials.access_token,\n          res: r.res\n        };\n      } else {\n        return {\n          token: _this5.credentials.access_token\n        };\n      }\n    })();\n  }\n  /**\n   * The main authentication interface.  It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * In OAuth2Client, the result has the form:\n   * { Authorization: 'Bearer <access_token_value>' }\n   * @param url The optional url being authorized\n   */\n  getRequestHeaders(url) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const headers = (yield _this6.getRequestMetadataAsync(url)).headers;\n      return headers;\n    })();\n  }\n  getRequestMetadataAsync(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  url) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const thisCreds = _this7.credentials;\n      if (!thisCreds.access_token && !thisCreds.refresh_token && !_this7.apiKey && !_this7.refreshHandler) {\n        throw new Error('No access, refresh token, API key or refresh handler callback is set.');\n      }\n      if (thisCreds.access_token && !_this7.isTokenExpiring()) {\n        thisCreds.token_type = thisCreds.token_type || 'Bearer';\n        const headers = {\n          Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n        };\n        return {\n          headers: _this7.addSharedMetadataHeaders(headers)\n        };\n      }\n      // If refreshHandler exists, call processAndValidateRefreshHandler().\n      if (_this7.refreshHandler) {\n        const refreshedAccessToken = yield _this7.processAndValidateRefreshHandler();\n        if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\n          _this7.setCredentials(refreshedAccessToken);\n          const headers = {\n            Authorization: 'Bearer ' + _this7.credentials.access_token\n          };\n          return {\n            headers: _this7.addSharedMetadataHeaders(headers)\n          };\n        }\n      }\n      if (_this7.apiKey) {\n        return {\n          headers: {\n            'X-Goog-Api-Key': _this7.apiKey\n          }\n        };\n      }\n      let r = null;\n      let tokens = null;\n      try {\n        r = yield _this7.refreshToken(thisCreds.refresh_token);\n        tokens = r.tokens;\n      } catch (err) {\n        const e = err;\n        if (e.response && (e.response.status === 403 || e.response.status === 404)) {\n          e.message = `Could not refresh access token: ${e.message}`;\n        }\n        throw e;\n      }\n      const credentials = _this7.credentials;\n      credentials.token_type = credentials.token_type || 'Bearer';\n      tokens.refresh_token = credentials.refresh_token;\n      _this7.credentials = tokens;\n      const headers = {\n        Authorization: credentials.token_type + ' ' + tokens.access_token\n      };\n      return {\n        headers: _this7.addSharedMetadataHeaders(headers),\n        res: r.res\n      };\n    })();\n  }\n  /**\n   * Generates an URL to revoke the given token.\n   * @param token The existing token to be revoked.\n   */\n  static getRevokeTokenUrl(token) {\n    const parameters = querystring.stringify({\n      token\n    });\n    return `${OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_}?${parameters}`;\n  }\n  revokeToken(token, callback) {\n    const opts = {\n      url: OAuth2Client.getRevokeTokenUrl(token),\n      method: 'POST'\n    };\n    if (callback) {\n      this.transporter.request(opts).then(r => callback(null, r), callback);\n    } else {\n      return this.transporter.request(opts);\n    }\n  }\n  revokeCredentials(callback) {\n    if (callback) {\n      this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n    } else {\n      return this.revokeCredentialsAsync();\n    }\n  }\n  revokeCredentialsAsync() {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const token = _this8.credentials.access_token;\n      _this8.credentials = {};\n      if (token) {\n        return _this8.revokeToken(token);\n      } else {\n        throw new Error('No access token to revoke.');\n      }\n    })();\n  }\n  request(opts, callback) {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n  requestAsync(opts, retry = false) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      let r2;\n      try {\n        const r = yield _this9.getRequestMetadataAsync(opts.url);\n        opts.headers = opts.headers || {};\n        if (r.headers && r.headers['x-goog-user-project']) {\n          opts.headers['x-goog-user-project'] = r.headers['x-goog-user-project'];\n        }\n        if (r.headers && r.headers.Authorization) {\n          opts.headers.Authorization = r.headers.Authorization;\n        }\n        if (_this9.apiKey) {\n          opts.headers['X-Goog-Api-Key'] = _this9.apiKey;\n        }\n        r2 = yield _this9.transporter.request(opts);\n      } catch (e) {\n        const res = e.response;\n        if (res) {\n          const statusCode = res.status;\n          // Retry the request for metadata if the following criteria are true:\n          // - We haven't already retried.  It only makes sense to retry once.\n          // - The response was a 401 or a 403\n          // - The request didn't send a readableStream\n          // - An access_token and refresh_token were available, but either no\n          //   expiry_date was available or the forceRefreshOnFailure flag is set.\n          //   The absent expiry_date case can happen when developers stash the\n          //   access_token and refresh_token for later use, but the access_token\n          //   fails on the first try because it's expired. Some developers may\n          //   choose to enable forceRefreshOnFailure to mitigate time-related\n          //   errors.\n          // Or the following criteria are true:\n          // - We haven't already retried.  It only makes sense to retry once.\n          // - The response was a 401 or a 403\n          // - The request didn't send a readableStream\n          // - No refresh_token was available\n          // - An access_token and a refreshHandler callback were available, but\n          //   either no expiry_date was available or the forceRefreshOnFailure\n          //   flag is set. The access_token fails on the first try because it's\n          //   expired. Some developers may choose to enable forceRefreshOnFailure\n          //   to mitigate time-related errors.\n          const mayRequireRefresh = _this9.credentials && _this9.credentials.access_token && _this9.credentials.refresh_token && (!_this9.credentials.expiry_date || _this9.forceRefreshOnFailure);\n          const mayRequireRefreshWithNoRefreshToken = _this9.credentials && _this9.credentials.access_token && !_this9.credentials.refresh_token && (!_this9.credentials.expiry_date || _this9.forceRefreshOnFailure) && _this9.refreshHandler;\n          const isReadableStream = res.config.data instanceof stream.Readable;\n          const isAuthErr = statusCode === 401 || statusCode === 403;\n          if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n            yield _this9.refreshAccessTokenAsync();\n            return _this9.requestAsync(opts, true);\n          } else if (!retry && isAuthErr && !isReadableStream && mayRequireRefreshWithNoRefreshToken) {\n            const refreshedAccessToken = yield _this9.processAndValidateRefreshHandler();\n            if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\n              _this9.setCredentials(refreshedAccessToken);\n            }\n            return _this9.requestAsync(opts, true);\n          }\n        }\n        throw e;\n      }\n      return r2;\n    })();\n  }\n  verifyIdToken(options, callback) {\n    // This function used to accept two arguments instead of an options object.\n    // Check the types to help users upgrade with less pain.\n    // This check can be removed after a 2.0 release.\n    if (callback && typeof callback !== 'function') {\n      throw new Error('This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n    }\n    if (callback) {\n      this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n    } else {\n      return this.verifyIdTokenAsync(options);\n    }\n  }\n  verifyIdTokenAsync(options) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      if (!options.idToken) {\n        throw new Error('The verifyIdToken method requires an ID Token');\n      }\n      const response = yield _this10.getFederatedSignonCertsAsync();\n      const login = yield _this10.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, OAuth2Client.ISSUERS_, options.maxExpiry);\n      return login;\n    })();\n  }\n  /**\n   * Obtains information about the provisioned access token.  Especially useful\n   * if you want to check the scopes that were provisioned to a given token.\n   *\n   * @param accessToken Required.  The Access Token for which you want to get\n   * user info.\n   */\n  getTokenInfo(accessToken) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        data\n      } = yield _this11.transporter.request({\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          Authorization: `Bearer ${accessToken}`\n        },\n        url: OAuth2Client.GOOGLE_TOKEN_INFO_URL\n      });\n      const info = Object.assign({\n        expiry_date: new Date().getTime() + data.expires_in * 1000,\n        scopes: data.scope.split(' ')\n      }, data);\n      delete info.expires_in;\n      delete info.scope;\n      return info;\n    })();\n  }\n  getFederatedSignonCerts(callback) {\n    if (callback) {\n      this.getFederatedSignonCertsAsync().then(r => callback(null, r.certs, r.res), callback);\n    } else {\n      return this.getFederatedSignonCertsAsync();\n    }\n  }\n  getFederatedSignonCertsAsync() {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const nowTime = new Date().getTime();\n      const format = (0, crypto_1.hasBrowserCrypto)() ? CertificateFormat.JWK : CertificateFormat.PEM;\n      if (_this12.certificateExpiry && nowTime < _this12.certificateExpiry.getTime() && _this12.certificateCacheFormat === format) {\n        return {\n          certs: _this12.certificateCache,\n          format\n        };\n      }\n      let res;\n      let url;\n      switch (format) {\n        case CertificateFormat.PEM:\n          url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_;\n          break;\n        case CertificateFormat.JWK:\n          url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_;\n          break;\n        default:\n          throw new Error(`Unsupported certificate format ${format}`);\n      }\n      try {\n        res = yield _this12.transporter.request({\n          url\n        });\n      } catch (e) {\n        if (e instanceof Error) {\n          e.message = `Failed to retrieve verification certificates: ${e.message}`;\n        }\n        throw e;\n      }\n      const cacheControl = res ? res.headers['cache-control'] : undefined;\n      let cacheAge = -1;\n      if (cacheControl) {\n        const pattern = new RegExp('max-age=([0-9]*)');\n        const regexResult = pattern.exec(cacheControl);\n        if (regexResult && regexResult.length === 2) {\n          // Cache results with max-age (in seconds)\n          cacheAge = Number(regexResult[1]) * 1000; // milliseconds\n        }\n      }\n\n      let certificates = {};\n      switch (format) {\n        case CertificateFormat.PEM:\n          certificates = res.data;\n          break;\n        case CertificateFormat.JWK:\n          for (const key of res.data.keys) {\n            certificates[key.kid] = key;\n          }\n          break;\n        default:\n          throw new Error(`Unsupported certificate format ${format}`);\n      }\n      const now = new Date();\n      _this12.certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n      _this12.certificateCache = certificates;\n      _this12.certificateCacheFormat = format;\n      return {\n        certs: certificates,\n        format,\n        res\n      };\n    })();\n  }\n  getIapPublicKeys(callback) {\n    if (callback) {\n      this.getIapPublicKeysAsync().then(r => callback(null, r.pubkeys, r.res), callback);\n    } else {\n      return this.getIapPublicKeysAsync();\n    }\n  }\n  getIapPublicKeysAsync() {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      let res;\n      const url = OAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_;\n      try {\n        res = yield _this13.transporter.request({\n          url\n        });\n      } catch (e) {\n        if (e instanceof Error) {\n          e.message = `Failed to retrieve verification certificates: ${e.message}`;\n        }\n        throw e;\n      }\n      return {\n        pubkeys: res.data,\n        res\n      };\n    })();\n  }\n  verifySignedJwtWithCerts() {\n    // To make the code compatible with browser SubtleCrypto we need to make\n    // this method async.\n    throw new Error('verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.');\n  }\n  /**\n   * Verify the id token is signed with the correct certificate\n   * and is from the correct audience.\n   * @param jwt The jwt to verify (The ID Token in this case).\n   * @param certs The array of certs to test the jwt against.\n   * @param requiredAudience The audience to test the jwt against.\n   * @param issuers The allowed issuers of the jwt (Optional).\n   * @param maxExpiry The max expiry the certificate can be (Optional).\n   * @return Returns a promise resolving to LoginTicket on verification.\n   */\n  verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {\n    return _asyncToGenerator(function* () {\n      const crypto = (0, crypto_1.createCrypto)();\n      if (!maxExpiry) {\n        maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;\n      }\n      const segments = jwt.split('.');\n      if (segments.length !== 3) {\n        throw new Error('Wrong number of segments in token: ' + jwt);\n      }\n      const signed = segments[0] + '.' + segments[1];\n      let signature = segments[2];\n      let envelope;\n      let payload;\n      try {\n        envelope = JSON.parse(crypto.decodeBase64StringUtf8(segments[0]));\n      } catch (err) {\n        if (err instanceof Error) {\n          err.message = `Can't parse token envelope: ${segments[0]}': ${err.message}`;\n        }\n        throw err;\n      }\n      if (!envelope) {\n        throw new Error(\"Can't parse token envelope: \" + segments[0]);\n      }\n      try {\n        payload = JSON.parse(crypto.decodeBase64StringUtf8(segments[1]));\n      } catch (err) {\n        if (err instanceof Error) {\n          err.message = `Can't parse token payload '${segments[0]}`;\n        }\n        throw err;\n      }\n      if (!payload) {\n        throw new Error(\"Can't parse token payload: \" + segments[1]);\n      }\n      if (!Object.prototype.hasOwnProperty.call(certs, envelope.kid)) {\n        // If this is not present, then there's no reason to attempt verification\n        throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\n      }\n      const cert = certs[envelope.kid];\n      if (envelope.alg === 'ES256') {\n        signature = formatEcdsa.joseToDer(signature, 'ES256').toString('base64');\n      }\n      const verified = yield crypto.verify(cert, signed, signature);\n      if (!verified) {\n        throw new Error('Invalid token signature: ' + jwt);\n      }\n      if (!payload.iat) {\n        throw new Error('No issue time in token: ' + JSON.stringify(payload));\n      }\n      if (!payload.exp) {\n        throw new Error('No expiration time in token: ' + JSON.stringify(payload));\n      }\n      const iat = Number(payload.iat);\n      if (isNaN(iat)) throw new Error('iat field using invalid format');\n      const exp = Number(payload.exp);\n      if (isNaN(exp)) throw new Error('exp field using invalid format');\n      const now = new Date().getTime() / 1000;\n      if (exp >= now + maxExpiry) {\n        throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));\n      }\n      const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n      const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n      if (now < earliest) {\n        throw new Error('Token used too early, ' + now + ' < ' + earliest + ': ' + JSON.stringify(payload));\n      }\n      if (now > latest) {\n        throw new Error('Token used too late, ' + now + ' > ' + latest + ': ' + JSON.stringify(payload));\n      }\n      if (issuers && issuers.indexOf(payload.iss) < 0) {\n        throw new Error('Invalid issuer, expected one of [' + issuers + '], but got ' + payload.iss);\n      }\n      // Check the audience matches if we have one\n      if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) {\n        const aud = payload.aud;\n        let audVerified = false;\n        // If the requiredAudience is an array, check if it contains token\n        // audience\n        if (requiredAudience.constructor === Array) {\n          audVerified = requiredAudience.indexOf(aud) > -1;\n        } else {\n          audVerified = aud === requiredAudience;\n        }\n        if (!audVerified) {\n          throw new Error('Wrong recipient, payload audience != requiredAudience');\n        }\n      }\n      return new loginticket_1.LoginTicket(envelope, payload);\n    })();\n  }\n  /**\n   * Returns a promise that resolves with AccessTokenResponse type if\n   * refreshHandler is defined.\n   * If not, nothing is returned.\n   */\n  processAndValidateRefreshHandler() {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      if (_this14.refreshHandler) {\n        const accessTokenResponse = yield _this14.refreshHandler();\n        if (!accessTokenResponse.access_token) {\n          throw new Error('No access token is returned by the refreshHandler callback.');\n        }\n        return accessTokenResponse;\n      }\n      return;\n    })();\n  }\n  /**\n   * Returns true if a token is expired or will expire within\n   * eagerRefreshThresholdMillismilliseconds.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   */\n  isTokenExpiring() {\n    const expiryDate = this.credentials.expiry_date;\n    return expiryDate ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis : false;\n  }\n}\nexports.OAuth2Client = OAuth2Client;\nOAuth2Client.GOOGLE_TOKEN_INFO_URL = 'https://oauth2.googleapis.com/tokeninfo';\n/**\n * The base URL for auth endpoints.\n */\nOAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = 'https://accounts.google.com/o/oauth2/v2/auth';\n/**\n * The base endpoint for token retrieval.\n */\nOAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = 'https://oauth2.googleapis.com/token';\n/**\n * The base endpoint to revoke tokens.\n */\nOAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = 'https://oauth2.googleapis.com/revoke';\n/**\n * Google Sign on certificates in PEM format.\n */\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v1/certs';\n/**\n * Google Sign on certificates in JWK format.\n */\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v3/certs';\n/**\n * Google Sign on certificates in JWK format.\n */\nOAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_ = 'https://www.gstatic.com/iap/verify/public_key';\n/**\n * Clock skew - five minutes in seconds\n */\nOAuth2Client.CLOCK_SKEW_SECS_ = 300;\n/**\n * Max Token Lifetime is one day in seconds\n */\nOAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;\n/**\n * The allowed oauth token issuers.\n */\nOAuth2Client.ISSUERS_ = ['accounts.google.com', 'https://accounts.google.com'];","map":{"version":3,"names":["_asyncToGenerator","require","default","Object","defineProperty","exports","value","OAuth2Client","CertificateFormat","CodeChallengeMethod","gaxios_1","querystring","stream","formatEcdsa","crypto_1","authclient_1","loginticket_1","AuthClient","constructor","optionsOrClientId","clientSecret","redirectUri","certificateCache","certificateExpiry","certificateCacheFormat","PEM","refreshTokenPromises","Map","opts","clientId","_clientId","_clientSecret","eagerRefreshThresholdMillis","forceRefreshOnFailure","generateAuthUrl","code_challenge_method","code_challenge","Error","response_type","client_id","redirect_uri","Array","isArray","scope","join","rootUrl","GOOGLE_OAUTH2_AUTH_BASE_URL_","stringify","generateCodeVerifier","generateCodeVerifierAsync","crypto","createCrypto","randomString","randomBytesBase64","codeVerifier","replace","unencodedCodeChallenge","sha256DigestBase64","codeChallenge","split","getToken","codeOrOptions","callback","options","code","getTokenAsync","then","r","tokens","res","e","response","_this","url","GOOGLE_OAUTH2_TOKEN_URL_","values","client_secret","grant_type","code_verifier","transporter","request","method","data","headers","expires_in","expiry_date","Date","getTime","emit","refreshToken","_this2","refreshTokenNoCache","has","get","p","delete","set","_this3","_a","refresh_token","GaxiosError","message","test","error_description","JSON","refreshAccessToken","refreshAccessTokenAsync","credentials","_this4","getAccessToken","getAccessTokenAsync","token","_this5","shouldRefresh","access_token","isTokenExpiring","refreshHandler","refreshedAccessToken","processAndValidateRefreshHandler","setCredentials","getRequestHeaders","_this6","getRequestMetadataAsync","_this7","thisCreds","apiKey","token_type","Authorization","addSharedMetadataHeaders","err","status","getRevokeTokenUrl","parameters","GOOGLE_OAUTH2_REVOKE_URL_","revokeToken","revokeCredentials","revokeCredentialsAsync","_this8","requestAsync","retry","_this9","r2","statusCode","mayRequireRefresh","mayRequireRefreshWithNoRefreshToken","isReadableStream","config","Readable","isAuthErr","verifyIdToken","verifyIdTokenAsync","_this10","idToken","getFederatedSignonCertsAsync","login","verifySignedJwtWithCertsAsync","certs","audience","ISSUERS_","maxExpiry","getTokenInfo","accessToken","_this11","GOOGLE_TOKEN_INFO_URL","info","assign","scopes","getFederatedSignonCerts","_this12","nowTime","format","hasBrowserCrypto","JWK","GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_","GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_","cacheControl","undefined","cacheAge","pattern","RegExp","regexResult","exec","length","Number","certificates","key","keys","kid","now","getIapPublicKeys","getIapPublicKeysAsync","pubkeys","_this13","GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_","verifySignedJwtWithCerts","jwt","requiredAudience","issuers","MAX_TOKEN_LIFETIME_SECS_","segments","signed","signature","envelope","payload","parse","decodeBase64StringUtf8","prototype","hasOwnProperty","call","cert","alg","joseToDer","toString","verified","verify","iat","exp","isNaN","earliest","CLOCK_SKEW_SECS_","latest","indexOf","iss","aud","audVerified","LoginTicket","_this14","accessTokenResponse","expiryDate"],"sources":["D:/graduation project/Graduation_Project-Dubbizel--main/Graduation_Project-Dubbizel--main/Dubbizel_Angular/node_modules/google-auth-library/build/src/auth/oauth2client.js"],"sourcesContent":["\"use strict\";\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OAuth2Client = exports.CertificateFormat = exports.CodeChallengeMethod = void 0;\nconst gaxios_1 = require(\"gaxios\");\nconst querystring = require(\"querystring\");\nconst stream = require(\"stream\");\nconst formatEcdsa = require(\"ecdsa-sig-formatter\");\nconst crypto_1 = require(\"../crypto/crypto\");\nconst authclient_1 = require(\"./authclient\");\nconst loginticket_1 = require(\"./loginticket\");\nvar CodeChallengeMethod;\n(function (CodeChallengeMethod) {\n    CodeChallengeMethod[\"Plain\"] = \"plain\";\n    CodeChallengeMethod[\"S256\"] = \"S256\";\n})(CodeChallengeMethod = exports.CodeChallengeMethod || (exports.CodeChallengeMethod = {}));\nvar CertificateFormat;\n(function (CertificateFormat) {\n    CertificateFormat[\"PEM\"] = \"PEM\";\n    CertificateFormat[\"JWK\"] = \"JWK\";\n})(CertificateFormat = exports.CertificateFormat || (exports.CertificateFormat = {}));\nclass OAuth2Client extends authclient_1.AuthClient {\n    constructor(optionsOrClientId, clientSecret, redirectUri) {\n        super();\n        this.certificateCache = {};\n        this.certificateExpiry = null;\n        this.certificateCacheFormat = CertificateFormat.PEM;\n        this.refreshTokenPromises = new Map();\n        const opts = optionsOrClientId && typeof optionsOrClientId === 'object'\n            ? optionsOrClientId\n            : { clientId: optionsOrClientId, clientSecret, redirectUri };\n        this._clientId = opts.clientId;\n        this._clientSecret = opts.clientSecret;\n        this.redirectUri = opts.redirectUri;\n        this.eagerRefreshThresholdMillis =\n            opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n        this.forceRefreshOnFailure = !!opts.forceRefreshOnFailure;\n    }\n    /**\n     * Generates URL for consent page landing.\n     * @param opts Options.\n     * @return URL to consent page.\n     */\n    generateAuthUrl(opts = {}) {\n        if (opts.code_challenge_method && !opts.code_challenge) {\n            throw new Error('If a code_challenge_method is provided, code_challenge must be included.');\n        }\n        opts.response_type = opts.response_type || 'code';\n        opts.client_id = opts.client_id || this._clientId;\n        opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n        // Allow scopes to be passed either as array or a string\n        if (Array.isArray(opts.scope)) {\n            opts.scope = opts.scope.join(' ');\n        }\n        const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n        return (rootUrl +\n            '?' +\n            querystring.stringify(opts));\n    }\n    generateCodeVerifier() {\n        // To make the code compatible with browser SubtleCrypto we need to make\n        // this method async.\n        throw new Error('generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.');\n    }\n    /**\n     * Convenience method to automatically generate a code_verifier, and its\n     * resulting SHA256. If used, this must be paired with a S256\n     * code_challenge_method.\n     *\n     * For a full example see:\n     * https://github.com/googleapis/google-auth-library-nodejs/blob/main/samples/oauth2-codeVerifier.js\n     */\n    async generateCodeVerifierAsync() {\n        // base64 encoding uses 6 bits per character, and we want to generate128\n        // characters. 6*128/8 = 96.\n        const crypto = (0, crypto_1.createCrypto)();\n        const randomString = crypto.randomBytesBase64(96);\n        // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n        // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n        // swapping out a few chars.\n        const codeVerifier = randomString\n            .replace(/\\+/g, '~')\n            .replace(/=/g, '_')\n            .replace(/\\//g, '-');\n        // Generate the base64 encoded SHA256\n        const unencodedCodeChallenge = await crypto.sha256DigestBase64(codeVerifier);\n        // We need to use base64UrlEncoding instead of standard base64\n        const codeChallenge = unencodedCodeChallenge\n            .split('=')[0]\n            .replace(/\\+/g, '-')\n            .replace(/\\//g, '_');\n        return { codeVerifier, codeChallenge };\n    }\n    getToken(codeOrOptions, callback) {\n        const options = typeof codeOrOptions === 'string' ? { code: codeOrOptions } : codeOrOptions;\n        if (callback) {\n            this.getTokenAsync(options).then(r => callback(null, r.tokens, r.res), e => callback(e, null, e.response));\n        }\n        else {\n            return this.getTokenAsync(options);\n        }\n    }\n    async getTokenAsync(options) {\n        const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n        const values = {\n            code: options.code,\n            client_id: options.client_id || this._clientId,\n            client_secret: this._clientSecret,\n            redirect_uri: options.redirect_uri || this.redirectUri,\n            grant_type: 'authorization_code',\n            code_verifier: options.codeVerifier,\n        };\n        const res = await this.transporter.request({\n            method: 'POST',\n            url,\n            data: querystring.stringify(values),\n            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n        });\n        const tokens = res.data;\n        if (res.data && res.data.expires_in) {\n            tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n            delete tokens.expires_in;\n        }\n        this.emit('tokens', tokens);\n        return { tokens, res };\n    }\n    /**\n     * Refreshes the access token.\n     * @param refresh_token Existing refresh token.\n     * @private\n     */\n    async refreshToken(refreshToken) {\n        if (!refreshToken) {\n            return this.refreshTokenNoCache(refreshToken);\n        }\n        // If a request to refresh using the same token has started,\n        // return the same promise.\n        if (this.refreshTokenPromises.has(refreshToken)) {\n            return this.refreshTokenPromises.get(refreshToken);\n        }\n        const p = this.refreshTokenNoCache(refreshToken).then(r => {\n            this.refreshTokenPromises.delete(refreshToken);\n            return r;\n        }, e => {\n            this.refreshTokenPromises.delete(refreshToken);\n            throw e;\n        });\n        this.refreshTokenPromises.set(refreshToken, p);\n        return p;\n    }\n    async refreshTokenNoCache(refreshToken) {\n        var _a;\n        if (!refreshToken) {\n            throw new Error('No refresh token is set.');\n        }\n        const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n        const data = {\n            refresh_token: refreshToken,\n            client_id: this._clientId,\n            client_secret: this._clientSecret,\n            grant_type: 'refresh_token',\n        };\n        let res;\n        try {\n            // request for new token\n            res = await this.transporter.request({\n                method: 'POST',\n                url,\n                data: querystring.stringify(data),\n                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n            });\n        }\n        catch (e) {\n            if (e instanceof gaxios_1.GaxiosError &&\n                e.message === 'invalid_grant' &&\n                ((_a = e.response) === null || _a === void 0 ? void 0 : _a.data) &&\n                /ReAuth/i.test(e.response.data.error_description)) {\n                e.message = JSON.stringify(e.response.data);\n            }\n            throw e;\n        }\n        const tokens = res.data;\n        // TODO: de-duplicate this code from a few spots\n        if (res.data && res.data.expires_in) {\n            tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n            delete tokens.expires_in;\n        }\n        this.emit('tokens', tokens);\n        return { tokens, res };\n    }\n    refreshAccessToken(callback) {\n        if (callback) {\n            this.refreshAccessTokenAsync().then(r => callback(null, r.credentials, r.res), callback);\n        }\n        else {\n            return this.refreshAccessTokenAsync();\n        }\n    }\n    async refreshAccessTokenAsync() {\n        const r = await this.refreshToken(this.credentials.refresh_token);\n        const tokens = r.tokens;\n        tokens.refresh_token = this.credentials.refresh_token;\n        this.credentials = tokens;\n        return { credentials: this.credentials, res: r.res };\n    }\n    getAccessToken(callback) {\n        if (callback) {\n            this.getAccessTokenAsync().then(r => callback(null, r.token, r.res), callback);\n        }\n        else {\n            return this.getAccessTokenAsync();\n        }\n    }\n    async getAccessTokenAsync() {\n        const shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();\n        if (shouldRefresh) {\n            if (!this.credentials.refresh_token) {\n                if (this.refreshHandler) {\n                    const refreshedAccessToken = await this.processAndValidateRefreshHandler();\n                    if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\n                        this.setCredentials(refreshedAccessToken);\n                        return { token: this.credentials.access_token };\n                    }\n                }\n                else {\n                    throw new Error('No refresh token or refresh handler callback is set.');\n                }\n            }\n            const r = await this.refreshAccessTokenAsync();\n            if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n                throw new Error('Could not refresh access token.');\n            }\n            return { token: r.credentials.access_token, res: r.res };\n        }\n        else {\n            return { token: this.credentials.access_token };\n        }\n    }\n    /**\n     * The main authentication interface.  It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * In OAuth2Client, the result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     * @param url The optional url being authorized\n     */\n    async getRequestHeaders(url) {\n        const headers = (await this.getRequestMetadataAsync(url)).headers;\n        return headers;\n    }\n    async getRequestMetadataAsync(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    url) {\n        const thisCreds = this.credentials;\n        if (!thisCreds.access_token &&\n            !thisCreds.refresh_token &&\n            !this.apiKey &&\n            !this.refreshHandler) {\n            throw new Error('No access, refresh token, API key or refresh handler callback is set.');\n        }\n        if (thisCreds.access_token && !this.isTokenExpiring()) {\n            thisCreds.token_type = thisCreds.token_type || 'Bearer';\n            const headers = {\n                Authorization: thisCreds.token_type + ' ' + thisCreds.access_token,\n            };\n            return { headers: this.addSharedMetadataHeaders(headers) };\n        }\n        // If refreshHandler exists, call processAndValidateRefreshHandler().\n        if (this.refreshHandler) {\n            const refreshedAccessToken = await this.processAndValidateRefreshHandler();\n            if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\n                this.setCredentials(refreshedAccessToken);\n                const headers = {\n                    Authorization: 'Bearer ' + this.credentials.access_token,\n                };\n                return { headers: this.addSharedMetadataHeaders(headers) };\n            }\n        }\n        if (this.apiKey) {\n            return { headers: { 'X-Goog-Api-Key': this.apiKey } };\n        }\n        let r = null;\n        let tokens = null;\n        try {\n            r = await this.refreshToken(thisCreds.refresh_token);\n            tokens = r.tokens;\n        }\n        catch (err) {\n            const e = err;\n            if (e.response &&\n                (e.response.status === 403 || e.response.status === 404)) {\n                e.message = `Could not refresh access token: ${e.message}`;\n            }\n            throw e;\n        }\n        const credentials = this.credentials;\n        credentials.token_type = credentials.token_type || 'Bearer';\n        tokens.refresh_token = credentials.refresh_token;\n        this.credentials = tokens;\n        const headers = {\n            Authorization: credentials.token_type + ' ' + tokens.access_token,\n        };\n        return { headers: this.addSharedMetadataHeaders(headers), res: r.res };\n    }\n    /**\n     * Generates an URL to revoke the given token.\n     * @param token The existing token to be revoked.\n     */\n    static getRevokeTokenUrl(token) {\n        const parameters = querystring.stringify({ token });\n        return `${OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_}?${parameters}`;\n    }\n    revokeToken(token, callback) {\n        const opts = {\n            url: OAuth2Client.getRevokeTokenUrl(token),\n            method: 'POST',\n        };\n        if (callback) {\n            this.transporter\n                .request(opts)\n                .then(r => callback(null, r), callback);\n        }\n        else {\n            return this.transporter.request(opts);\n        }\n    }\n    revokeCredentials(callback) {\n        if (callback) {\n            this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n        }\n        else {\n            return this.revokeCredentialsAsync();\n        }\n    }\n    async revokeCredentialsAsync() {\n        const token = this.credentials.access_token;\n        this.credentials = {};\n        if (token) {\n            return this.revokeToken(token);\n        }\n        else {\n            throw new Error('No access token to revoke.');\n        }\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then(r => callback(null, r), e => {\n                return callback(e, e.response);\n            });\n        }\n        else {\n            return this.requestAsync(opts);\n        }\n    }\n    async requestAsync(opts, retry = false) {\n        let r2;\n        try {\n            const r = await this.getRequestMetadataAsync(opts.url);\n            opts.headers = opts.headers || {};\n            if (r.headers && r.headers['x-goog-user-project']) {\n                opts.headers['x-goog-user-project'] = r.headers['x-goog-user-project'];\n            }\n            if (r.headers && r.headers.Authorization) {\n                opts.headers.Authorization = r.headers.Authorization;\n            }\n            if (this.apiKey) {\n                opts.headers['X-Goog-Api-Key'] = this.apiKey;\n            }\n            r2 = await this.transporter.request(opts);\n        }\n        catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - An access_token and refresh_token were available, but either no\n                //   expiry_date was available or the forceRefreshOnFailure flag is set.\n                //   The absent expiry_date case can happen when developers stash the\n                //   access_token and refresh_token for later use, but the access_token\n                //   fails on the first try because it's expired. Some developers may\n                //   choose to enable forceRefreshOnFailure to mitigate time-related\n                //   errors.\n                // Or the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - No refresh_token was available\n                // - An access_token and a refreshHandler callback were available, but\n                //   either no expiry_date was available or the forceRefreshOnFailure\n                //   flag is set. The access_token fails on the first try because it's\n                //   expired. Some developers may choose to enable forceRefreshOnFailure\n                //   to mitigate time-related errors.\n                const mayRequireRefresh = this.credentials &&\n                    this.credentials.access_token &&\n                    this.credentials.refresh_token &&\n                    (!this.credentials.expiry_date || this.forceRefreshOnFailure);\n                const mayRequireRefreshWithNoRefreshToken = this.credentials &&\n                    this.credentials.access_token &&\n                    !this.credentials.refresh_token &&\n                    (!this.credentials.expiry_date || this.forceRefreshOnFailure) &&\n                    this.refreshHandler;\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n                    await this.refreshAccessTokenAsync();\n                    return this.requestAsync(opts, true);\n                }\n                else if (!retry &&\n                    isAuthErr &&\n                    !isReadableStream &&\n                    mayRequireRefreshWithNoRefreshToken) {\n                    const refreshedAccessToken = await this.processAndValidateRefreshHandler();\n                    if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\n                        this.setCredentials(refreshedAccessToken);\n                    }\n                    return this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return r2;\n    }\n    verifyIdToken(options, callback) {\n        // This function used to accept two arguments instead of an options object.\n        // Check the types to help users upgrade with less pain.\n        // This check can be removed after a 2.0 release.\n        if (callback && typeof callback !== 'function') {\n            throw new Error('This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n        }\n        if (callback) {\n            this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n        }\n        else {\n            return this.verifyIdTokenAsync(options);\n        }\n    }\n    async verifyIdTokenAsync(options) {\n        if (!options.idToken) {\n            throw new Error('The verifyIdToken method requires an ID Token');\n        }\n        const response = await this.getFederatedSignonCertsAsync();\n        const login = await this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, OAuth2Client.ISSUERS_, options.maxExpiry);\n        return login;\n    }\n    /**\n     * Obtains information about the provisioned access token.  Especially useful\n     * if you want to check the scopes that were provisioned to a given token.\n     *\n     * @param accessToken Required.  The Access Token for which you want to get\n     * user info.\n     */\n    async getTokenInfo(accessToken) {\n        const { data } = await this.transporter.request({\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n                Authorization: `Bearer ${accessToken}`,\n            },\n            url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n        });\n        const info = Object.assign({\n            expiry_date: new Date().getTime() + data.expires_in * 1000,\n            scopes: data.scope.split(' '),\n        }, data);\n        delete info.expires_in;\n        delete info.scope;\n        return info;\n    }\n    getFederatedSignonCerts(callback) {\n        if (callback) {\n            this.getFederatedSignonCertsAsync().then(r => callback(null, r.certs, r.res), callback);\n        }\n        else {\n            return this.getFederatedSignonCertsAsync();\n        }\n    }\n    async getFederatedSignonCertsAsync() {\n        const nowTime = new Date().getTime();\n        const format = (0, crypto_1.hasBrowserCrypto)()\n            ? CertificateFormat.JWK\n            : CertificateFormat.PEM;\n        if (this.certificateExpiry &&\n            nowTime < this.certificateExpiry.getTime() &&\n            this.certificateCacheFormat === format) {\n            return { certs: this.certificateCache, format };\n        }\n        let res;\n        let url;\n        switch (format) {\n            case CertificateFormat.PEM:\n                url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_;\n                break;\n            case CertificateFormat.JWK:\n                url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_;\n                break;\n            default:\n                throw new Error(`Unsupported certificate format ${format}`);\n        }\n        try {\n            res = await this.transporter.request({ url });\n        }\n        catch (e) {\n            if (e instanceof Error) {\n                e.message = `Failed to retrieve verification certificates: ${e.message}`;\n            }\n            throw e;\n        }\n        const cacheControl = res ? res.headers['cache-control'] : undefined;\n        let cacheAge = -1;\n        if (cacheControl) {\n            const pattern = new RegExp('max-age=([0-9]*)');\n            const regexResult = pattern.exec(cacheControl);\n            if (regexResult && regexResult.length === 2) {\n                // Cache results with max-age (in seconds)\n                cacheAge = Number(regexResult[1]) * 1000; // milliseconds\n            }\n        }\n        let certificates = {};\n        switch (format) {\n            case CertificateFormat.PEM:\n                certificates = res.data;\n                break;\n            case CertificateFormat.JWK:\n                for (const key of res.data.keys) {\n                    certificates[key.kid] = key;\n                }\n                break;\n            default:\n                throw new Error(`Unsupported certificate format ${format}`);\n        }\n        const now = new Date();\n        this.certificateExpiry =\n            cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n        this.certificateCache = certificates;\n        this.certificateCacheFormat = format;\n        return { certs: certificates, format, res };\n    }\n    getIapPublicKeys(callback) {\n        if (callback) {\n            this.getIapPublicKeysAsync().then(r => callback(null, r.pubkeys, r.res), callback);\n        }\n        else {\n            return this.getIapPublicKeysAsync();\n        }\n    }\n    async getIapPublicKeysAsync() {\n        let res;\n        const url = OAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_;\n        try {\n            res = await this.transporter.request({ url });\n        }\n        catch (e) {\n            if (e instanceof Error) {\n                e.message = `Failed to retrieve verification certificates: ${e.message}`;\n            }\n            throw e;\n        }\n        return { pubkeys: res.data, res };\n    }\n    verifySignedJwtWithCerts() {\n        // To make the code compatible with browser SubtleCrypto we need to make\n        // this method async.\n        throw new Error('verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.');\n    }\n    /**\n     * Verify the id token is signed with the correct certificate\n     * and is from the correct audience.\n     * @param jwt The jwt to verify (The ID Token in this case).\n     * @param certs The array of certs to test the jwt against.\n     * @param requiredAudience The audience to test the jwt against.\n     * @param issuers The allowed issuers of the jwt (Optional).\n     * @param maxExpiry The max expiry the certificate can be (Optional).\n     * @return Returns a promise resolving to LoginTicket on verification.\n     */\n    async verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {\n        const crypto = (0, crypto_1.createCrypto)();\n        if (!maxExpiry) {\n            maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;\n        }\n        const segments = jwt.split('.');\n        if (segments.length !== 3) {\n            throw new Error('Wrong number of segments in token: ' + jwt);\n        }\n        const signed = segments[0] + '.' + segments[1];\n        let signature = segments[2];\n        let envelope;\n        let payload;\n        try {\n            envelope = JSON.parse(crypto.decodeBase64StringUtf8(segments[0]));\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                err.message = `Can't parse token envelope: ${segments[0]}': ${err.message}`;\n            }\n            throw err;\n        }\n        if (!envelope) {\n            throw new Error(\"Can't parse token envelope: \" + segments[0]);\n        }\n        try {\n            payload = JSON.parse(crypto.decodeBase64StringUtf8(segments[1]));\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                err.message = `Can't parse token payload '${segments[0]}`;\n            }\n            throw err;\n        }\n        if (!payload) {\n            throw new Error(\"Can't parse token payload: \" + segments[1]);\n        }\n        if (!Object.prototype.hasOwnProperty.call(certs, envelope.kid)) {\n            // If this is not present, then there's no reason to attempt verification\n            throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\n        }\n        const cert = certs[envelope.kid];\n        if (envelope.alg === 'ES256') {\n            signature = formatEcdsa.joseToDer(signature, 'ES256').toString('base64');\n        }\n        const verified = await crypto.verify(cert, signed, signature);\n        if (!verified) {\n            throw new Error('Invalid token signature: ' + jwt);\n        }\n        if (!payload.iat) {\n            throw new Error('No issue time in token: ' + JSON.stringify(payload));\n        }\n        if (!payload.exp) {\n            throw new Error('No expiration time in token: ' + JSON.stringify(payload));\n        }\n        const iat = Number(payload.iat);\n        if (isNaN(iat))\n            throw new Error('iat field using invalid format');\n        const exp = Number(payload.exp);\n        if (isNaN(exp))\n            throw new Error('exp field using invalid format');\n        const now = new Date().getTime() / 1000;\n        if (exp >= now + maxExpiry) {\n            throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));\n        }\n        const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n        const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n        if (now < earliest) {\n            throw new Error('Token used too early, ' +\n                now +\n                ' < ' +\n                earliest +\n                ': ' +\n                JSON.stringify(payload));\n        }\n        if (now > latest) {\n            throw new Error('Token used too late, ' +\n                now +\n                ' > ' +\n                latest +\n                ': ' +\n                JSON.stringify(payload));\n        }\n        if (issuers && issuers.indexOf(payload.iss) < 0) {\n            throw new Error('Invalid issuer, expected one of [' +\n                issuers +\n                '], but got ' +\n                payload.iss);\n        }\n        // Check the audience matches if we have one\n        if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) {\n            const aud = payload.aud;\n            let audVerified = false;\n            // If the requiredAudience is an array, check if it contains token\n            // audience\n            if (requiredAudience.constructor === Array) {\n                audVerified = requiredAudience.indexOf(aud) > -1;\n            }\n            else {\n                audVerified = aud === requiredAudience;\n            }\n            if (!audVerified) {\n                throw new Error('Wrong recipient, payload audience != requiredAudience');\n            }\n        }\n        return new loginticket_1.LoginTicket(envelope, payload);\n    }\n    /**\n     * Returns a promise that resolves with AccessTokenResponse type if\n     * refreshHandler is defined.\n     * If not, nothing is returned.\n     */\n    async processAndValidateRefreshHandler() {\n        if (this.refreshHandler) {\n            const accessTokenResponse = await this.refreshHandler();\n            if (!accessTokenResponse.access_token) {\n                throw new Error('No access token is returned by the refreshHandler callback.');\n            }\n            return accessTokenResponse;\n        }\n        return;\n    }\n    /**\n     * Returns true if a token is expired or will expire within\n     * eagerRefreshThresholdMillismilliseconds.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     */\n    isTokenExpiring() {\n        const expiryDate = this.credentials.expiry_date;\n        return expiryDate\n            ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis\n            : false;\n    }\n}\nexports.OAuth2Client = OAuth2Client;\nOAuth2Client.GOOGLE_TOKEN_INFO_URL = 'https://oauth2.googleapis.com/tokeninfo';\n/**\n * The base URL for auth endpoints.\n */\nOAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = 'https://accounts.google.com/o/oauth2/v2/auth';\n/**\n * The base endpoint for token retrieval.\n */\nOAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = 'https://oauth2.googleapis.com/token';\n/**\n * The base endpoint to revoke tokens.\n */\nOAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = 'https://oauth2.googleapis.com/revoke';\n/**\n * Google Sign on certificates in PEM format.\n */\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v1/certs';\n/**\n * Google Sign on certificates in JWK format.\n */\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v3/certs';\n/**\n * Google Sign on certificates in JWK format.\n */\nOAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_ = 'https://www.gstatic.com/iap/verify/public_key';\n/**\n * Clock skew - five minutes in seconds\n */\nOAuth2Client.CLOCK_SKEW_SECS_ = 300;\n/**\n * Max Token Lifetime is one day in seconds\n */\nOAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;\n/**\n * The allowed oauth token issuers.\n */\nOAuth2Client.ISSUERS_ = [\n    'accounts.google.com',\n    'https://accounts.google.com',\n];\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}